/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-markdown";
exports.ids = ["vendor-chunks/simple-markdown"];
exports.modules = {

/***/ "(ssr)/./node_modules/simple-markdown/simple-markdown.js":
/*!*********************************************************!*\
  !*** ./node_modules/simple-markdown/simple-markdown.js ***!
  \*********************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n true ? module.exports = factory() :\n0;\n}(this, (function () { 'use strict';\n\n/* @flow */\n/* @ts-check */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n// Typescript language & simple-markdown.d.ts references:\n/// <reference lib=\"ES2018\" />\n/// <reference path=\"../simple-markdown.d.ts\" />\n\n/*::\n// Flow Type Definitions:\n\ntype Capture =\n    Array<string> & {index: number} |\n    Array<string> & {index?: number};\n\ntype Attr = string | number | boolean | null | void;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {\n    key?: string | number | void,\n    inline?: ?boolean,\n    [string]: any,\n};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = { regex?: RegExp } & (\n    source: string,\n    state: State,\n    prevCapture: string\n) => ?Capture;\n\ntype Parser = (\n    source: string,\n    state?: ?State\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => (UnTypedASTNode | ASTNode);\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: ?State\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n};\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +tableSeparator: DefaultInRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n    alt?: string,\n};\n\n// End Flow Definitions\n*/\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n * @param {string} source\n * @returns {string}\n */\nvar preprocess = function(source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\n/**\n * @param {SimpleMarkdown.OptionalState} givenState\n * @param {SimpleMarkdown.OptionalState} defaultState\n * @returns {SimpleMarkdown.State}\n */\nvar populateInitialState = function(\n    givenState /* : ?State */,\n    defaultState /* : ?State */\n) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function(type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                String(order)\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var ruleA /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeA] /*:: :any */);\n        var ruleB /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeB] /*:: :any */);\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.Parser} */\n    var nestedParse = function(source /* : string */, state /* : ?State */) {\n        /** @type Array<SimpleMarkdown.SingleASTNode> */\n        var result = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n            var currRule /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ ( rules[currRuleType] /*:: :any */ );\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality ? currRule.quality(\n                        currCapture,\n                        state,\n                        prevCaptureStr\n                    ) : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = /*::((*/ /** @type {SimpleMarkdown.ParserRule} */ (rules[currRuleType]) /*:: : any) : ParserRule)*/;\n\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule && (\n                    // if we don't have a match yet, continue\n                    !capture || (\n                        // or if we have a match, but the next rule is\n                        // at the same order, and has a quality measurement\n                        // functions, then this rule must have a quality\n                        // measurement function (since they are sorted before\n                        // those without), and we need to check if there is\n                        // a better quality match\n                        currRule.order === currOrder &&\n                        currRule.quality\n                    )\n                )\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null /*:: || ruleType == null */) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                    \"content. The rule with highest `order` should \" +\n                    \"always match content provided to it. Check \" +\n                    \"the definition of `match` for '\" +\n                    ruleList[ruleList.length - 1] +\n                    \"'. It seems to not match the following source:\\n\" +\n                    source\n                );\n            }\n            if (capture.index) { // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                    \"(the current parse index). Did you forget a ^ at the \" +\n                    \"start of the RegExp?\"\n                );\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(/** @type {SimpleMarkdown.SingleASTNode} */ (parsed));\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n        return result;\n    };\n\n    /** @type {SimpleMarkdown.Parser} */\n    var outerParse = function(source /* : string */, state /* : ?State */) {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar inlineRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar blockRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar anyScopeRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\n/**\n * @param {string} type\n * @param {string | number | null | undefined} key\n * @param {Object<string, any>} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar reactElement = function(\n    type /* : string */,\n    key /* : string | number | null | void */,\n    props /* : { [string]: any } */\n) /* : ReactElement */ {\n    var element /* : ReactElement */ = /** @type {SimpleMarkdown.ReactElement} */ ({\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null\n    } /* : any */);\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function(\n    tagName /* : string */,\n    content /* : string */,\n    attributes /* : ?{[any]: ?Attr} */,\n    isClosed /* : ?boolean */\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attribute) {\n            attributeString += \" \" +\n                sanitizeText(attr) + '=\"' +\n                sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function(url /* : ?string */) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\n/** @type {any} */\nvar SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n};\n/**\n * @param {SimpleMarkdown.Attr} text\n * @returns {string}\n */\nvar sanitizeText = function(text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function(chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\n/**\n * @param {string} rawUrlString\n * @returns {string}\n */\nvar unescapeUrl = function(rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n *\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n/**\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.Parser} parse\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\n/**\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function() {\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    /**\n     * @param {string} alignCapture\n     * @returns {SimpleMarkdown.TableAlignment}\n     */\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {Array<SimpleMarkdown.TableAlignment>}\n     */\n    var parseTableAlign = function(source, parse, state, trimEndSeparators) {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleASTNode[][]}\n     */\n    var parseTableRow = function(source, parse, state, trimEndSeparators) {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        /** @type {SimpleMarkdown.SingleASTNode[][]} */\n        var cells = [[]];\n        tableRow.forEach(function(node, i) {\n            if (node.type === 'tableSeparator') {\n                // Filter out empty table separators at the start/end:\n                if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (node.type === 'text' && (\n                    tableRow[i + 1] == null ||\n                    tableRow[i + 1].type === 'tableSeparator'\n                )) {\n                    node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function(source, parse, state, trimEndSeparators) {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function(trimEndSeparators) {\n        /** @type {SimpleMarkdown.SingleNodeParseFunction} */\n        return function(capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n            var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n            var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.State} state\n * @param {SimpleMarkdown.RefNode} refNode\n * @returns {SimpleMarkdown.RefNode}\n */\nvar parseRef = function(capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n/** @type {SimpleMarkdown.DefaultRules} */\nvar defaultRules /* : DefaultRules */ = {\n    Array: {\n        react: function(arr, output, state) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = '' + i;\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function(arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0; i < arr.length; i++) {\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        }\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'h' + node.level,\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        },\n        react: null,\n        html: null\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'hr',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        }\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement(\n                'pre',\n                state.key,\n                {\n                    children: reactElement(\n                        'code',\n                        null,\n                        {\n                            className: className,\n                            children: node.content\n                        }\n                    )\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        }\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        },\n        react: null,\n        html: null\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content, state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'blockquote',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    list: {\n        order: currOrder++,\n        match: function(source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = /** @type {string[]} */ (\n                capture[0]\n                    .replace(LIST_BLOCK_END_R, \"\\n\")\n                    .match(LIST_ITEM_R)\n            );\n\n            // We know this will match here, because of how the regexes are\n            // defined\n            /*:: items = ((items : any) : Array<string>) */\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(/** @type {string} */ item, /** @type {number} */ i) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // I'm not sur4 why this is necessary again?\n                /*:: items = ((items : any) : Array<string>) */\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(\n                ListWrapper,\n                state.key,\n                {\n                    start: node.start,\n                    children: node.items.map(function(\n                        /** @type {SimpleMarkdown.ASTNode} */ item,\n                        /** @type {number} */ i\n                    ) {\n                        return reactElement(\n                            'li',\n                            '' + i,\n                            {\n                                children: output(item, state)\n                            }\n                        );\n                    })\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(/** @type {SimpleMarkdown.ASTNode} */ item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(/** @type {SimpleMarkdown.RefNode} */ refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return \"\"; }\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {{ [attr: string]: SimpleMarkdown.Attr }}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return reactElement(\n                    'th',\n                    '' + i,\n                    {\n                        style: getStyle(i),\n                        scope: 'col',\n                        children: output(content, state)\n                    }\n                );\n            });\n\n            var rows = node.cells.map(function(\n                    /** @type {SimpleMarkdown.ASTNode[]} */ row,\n                    /** @type {number} */ r\n            ) {\n                return reactElement(\n                    'tr',\n                    '' + r,\n                    {\n                        children: row.map(function(\n                            /** @type {SimpleMarkdown.ASTNode} */ content,\n                            /** @type {number} */ c\n                        ) {\n                            return reactElement(\n                                'td',\n                                '' + c,\n                                {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                }\n                            );\n                        })\n                    }\n                );\n            });\n\n            return reactElement(\n                'table',\n                state.key,\n                {\n                    children: [reactElement(\n                        'thead',\n                        'thead',\n                        {\n                            children: reactElement(\n                                'tr',\n                                null,\n                                {\n                                    children: headers\n                                }\n                            )\n                        }\n                    ), reactElement(\n                        'tbody',\n                        'tbody',\n                        {\n                            children: rows\n                        }\n                    )]\n                }\n            );\n        },\n        html: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {string}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i), scope: \"col\" });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(/** @type {SimpleMarkdown.ASTNode[]} */ row) {\n                var cols = row.map(function(\n                    /** @type {SimpleMarkdown.ASTNode} */ content,\n                    /** @type {number} */ c\n                ) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        }\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; }\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'div',\n                state.key,\n                {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function(source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function() {\n            return { type: 'tableSeparator' };\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function() { return ' | '; },\n        html: function() { return ' &vert; '; },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        },\n        react: null,\n        html: null\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        },\n        react: null,\n        html: null\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'a',\n                state.key,\n                {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'img',\n                state.key,\n                {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        },\n        react: null,\n        html: null\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        },\n        react: null,\n        html: null\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match at least one of:\n                \"(?:\" +\n                  //  - `**`: so that bolds inside italics don't close the\n                  //          italics\n                  \"\\\\*\\\\*|\" +\n                  //  - escape sequence: so escaped *s don't close us\n                  \"\\\\\\\\[\\\\s\\\\S]|\" +\n                  //  - whitespace: followed by a non-* (we don't\n                  //          want ' *' to close an italics--it might\n                  //          start a list)\n                  \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                  //  - non-whitespace, non-*, non-backslash characters\n                  \"[^\\\\s\\\\*\\\\\\\\]\" +\n                \")+?\" +\n                // followed by a non-space, non-* then *\n                \")\\\\*(?!\\\\*)\"\n            )\n        ),\n        quality: function(capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'em',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        }\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function(capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'strong',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function(capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'u',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        }\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'del',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'code',\n                state.key,\n                {\n                    children: node.content\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        }\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'br',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        }\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return sanitizeText(node.content);\n        }\n    }\n};\n\n/** (deprecated)\n * @param {any} rules\n * @param {any} property\n * @returns {any}\n */\nvar ruleOutput = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    /** @type {SimpleMarkdown.NodeOutput<any>} */\n    var nestedRuleOutput /* : NodeOutput<any> */ = function(\n        ast /* : SingleASTNode */,\n        outputFunc /* : Output<any> */,\n        state /* : State */\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar reactFor = function(outputFunc /* : ReactNodeOutput */) /* : ReactOutput */ {\n    /** @type {SimpleMarkdown.ReactOutput} */\n    var nestedOutput /* : ReactOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = '' + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar htmlFor = function(outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */ {\n    /** @type {SimpleMarkdown.HtmlOutput} */\n    var nestedOutput /* : HtmlOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/**\n * @type {SimpleMarkdown.OutputFor}\n */\nvar outputFor = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */,\n    defaultState /* : ?State */\n) {\n    if (!property) {\n        throw new Error('simple-markdown: outputFor: `property` must be ' +\n            'defined. ' +\n            'if you just upgraded, you probably need to replace `outputFor` ' +\n            'with `reactFor`'\n        );\n    }\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.ArrayRule} */\n    var arrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error('simple-markdown: outputFor: to join nodes of type `' +\n            property + '` you must provide an `Array:` joiner rule with that type, ' +\n            'Please see the docs for details on specifying an Array rule.'\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var nestedOutput /* : Output<any> */ = function(ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var outerOutput = function(ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultBlockParse = function(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultInlineParse = function(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultImplicitParse = function(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\n/** @type {SimpleMarkdown.ReactOutput} */\nvar defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\n/** @type {SimpleMarkdown.HtmlOutput} */\nvar defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {SimpleMarkdown.ReactElements}\n */\nvar markdownToReact = function(source, state) /* : ReactElements */ {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {string}\n */\nvar markdownToHtml = function(source, state) /* : string */ {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n/**\n * @param {SimpleMarkdown.ReactMarkdownProps} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar ReactMarkdown = function(props) {\n    /** @type {Object} */\n    var divProps = {};\n\n    for (var prop in props) {\n        if (prop !== 'source' &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\n        'div',\n        null,\n        divProps\n    );\n};\n\n\n/*:: // Flow exports:\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n\n    +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (tagName: string, content: string, attributes: ?{ [any]: ?Attr }, isClosed: ?boolean) => string,\n    +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n};\n*/\n\nvar SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n        }\n        return defaultImplicitParse.apply(null, /** @type {any} */ (arguments));\n    },\n    defaultOutput: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n        }\n        return defaultReactOutput.apply(null, /** @type {any} */ (arguments));\n    }\n};\n\nreturn SimpleMarkdown;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ltcGxlLW1hcmtkb3duL3NpbXBsZS1tYXJrZG93bi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQTREO0FBQzVELENBQzREO0FBQzVELENBQUMsc0JBQXNCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEMscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEdBQUc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy92YXJ1bmlzcmFuaS9zcy9ub2RlX21vZHVsZXMvc2ltcGxlLW1hcmtkb3duL3NpbXBsZS1tYXJrZG93bi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlNpbXBsZU1hcmtkb3duID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiBAZmxvdyAqL1xuLyogQHRzLWNoZWNrICovXG5cbi8qKlxuICogU2ltcGxlLU1hcmtkb3duXG4gKiA9PT09PT09PT09PT09PT1cbiAqXG4gKiBTaW1wbGUtTWFya2Rvd24ncyBwcmltYXJ5IGdvYWwgaXMgdG8gYmUgZWFzeSB0byBhZGFwdC4gSXQgYWltc1xuICogdG8gYmUgY29tcGxpYW50IHdpdGggSm9obiBHcnViZXIncyBbTWFya2Rvd24gU3ludGF4IHBhZ2VdWzFdLFxuICogYnV0IGNvbXBhdGlibGl0eSB3aXRoIG90aGVyIG1hcmtkb3duIGltcGxlbWVudGF0aW9ucycgZWRnZS1jYXNlc1xuICogd2lsbCBiZSBzYWNyaWZpY2VkIHdoZXJlIGl0IGNvbmZsaWN0cyB3aXRoIHNpbXBsaWNpdHkgb3JcbiAqIGV4dGVuc2liaWxpdHkuXG4gKlxuICogSWYgeW91ciBnb2FsIGlzIHRvIHNpbXBseSBlbWJlZCBhIHN0YW5kYXJkIG1hcmtkb3duIGltcGxlbWVudGF0aW9uXG4gKiBpbiB5b3VyIHdlYnNpdGUsIHNpbXBsZS1tYXJrZG93biBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3QgbGlicmFyeVxuICogZm9yIHlvdSAoYWx0aG91Z2ggaXQgc2hvdWxkIHdvcmspLiBCdXQgaWYgeW91IGhhdmUgc3RydWdnbGVkIHRvXG4gKiBjdXN0b21pemUgYW4gZXhpc3RpbmcgbGlicmFyeSB0byBtZWV0IHlvdXIgbmVlZHMsIHNpbXBsZS1tYXJrZG93blxuICogbWlnaHQgYmUgYWJsZSB0byBoZWxwLlxuICpcbiAqIE1hbnkgb2YgdGhlIHJlZ2V4ZXMgYW5kIG9yaWdpbmFsIGxvZ2ljIGhhcyBiZWVuIGFkYXB0ZWQgZnJvbVxuICogdGhlIHdvbmRlcmZ1bCBbbWFya2VkLmpzXShodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWQpXG4gKlxuICogTElDRU5TRSAoTUlUKTpcbiAqIE5ldyBjb2RlIGNvcHlyaWdodCAoYykgMjAxNC0yMDE5IEtoYW4gQWNhZGVteSAmIEFyaWEgQnVja2xlcy5cbiAqXG4gKiBQb3J0aW9ucyBhZGFwdGVkIGZyb20gbWFya2VkLmpzIGNvcHlyaWdodCAoYykgMjAxMS0yMDE0XG4gKiBDaHJpc3RvcGhlciBKZWZmcmV5IChodHRwczovL2dpdGh1Yi5jb20vY2hqai8pLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLy8gVHlwZXNjcmlwdCBsYW5ndWFnZSAmIHNpbXBsZS1tYXJrZG93bi5kLnRzIHJlZmVyZW5jZXM6XG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJFUzIwMThcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL3NpbXBsZS1tYXJrZG93bi5kLnRzXCIgLz5cblxuLyo6OlxuLy8gRmxvdyBUeXBlIERlZmluaXRpb25zOlxuXG50eXBlIENhcHR1cmUgPVxuICAgIEFycmF5PHN0cmluZz4gJiB7aW5kZXg6IG51bWJlcn0gfFxuICAgIEFycmF5PHN0cmluZz4gJiB7aW5kZXg/OiBudW1iZXJ9O1xuXG50eXBlIEF0dHIgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCB8IHZvaWQ7XG5cbnR5cGUgU2luZ2xlQVNUTm9kZSA9IHtcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgW3N0cmluZ106IGFueSxcbn07XG5cbnR5cGUgVW5UeXBlZEFTVE5vZGUgPSB7XG4gICAgW3N0cmluZ106IGFueVxufTtcblxudHlwZSBBU1ROb2RlID0gU2luZ2xlQVNUTm9kZSB8IEFycmF5PFNpbmdsZUFTVE5vZGU+O1xuXG50eXBlIFN0YXRlID0ge1xuICAgIGtleT86IHN0cmluZyB8IG51bWJlciB8IHZvaWQsXG4gICAgaW5saW5lPzogP2Jvb2xlYW4sXG4gICAgW3N0cmluZ106IGFueSxcbn07XG5cbnR5cGUgUmVhY3RFbGVtZW50ID0gUmVhY3QkRWxlbWVudDxhbnk+O1xudHlwZSBSZWFjdEVsZW1lbnRzID0gUmVhY3QkTm9kZTtcblxudHlwZSBNYXRjaEZ1bmN0aW9uID0geyByZWdleD86IFJlZ0V4cCB9ICYgKFxuICAgIHNvdXJjZTogc3RyaW5nLFxuICAgIHN0YXRlOiBTdGF0ZSxcbiAgICBwcmV2Q2FwdHVyZTogc3RyaW5nXG4pID0+ID9DYXB0dXJlO1xuXG50eXBlIFBhcnNlciA9IChcbiAgICBzb3VyY2U6IHN0cmluZyxcbiAgICBzdGF0ZT86ID9TdGF0ZVxuKSA9PiBBcnJheTxTaW5nbGVBU1ROb2RlPjtcblxudHlwZSBQYXJzZUZ1bmN0aW9uID0gKFxuICAgIGNhcHR1cmU6IENhcHR1cmUsXG4gICAgbmVzdGVkUGFyc2U6IFBhcnNlcixcbiAgICBzdGF0ZTogU3RhdGUsXG4pID0+IChVblR5cGVkQVNUTm9kZSB8IEFTVE5vZGUpO1xuXG50eXBlIFNpbmdsZU5vZGVQYXJzZUZ1bmN0aW9uID0gKFxuICAgIGNhcHR1cmU6IENhcHR1cmUsXG4gICAgbmVzdGVkUGFyc2U6IFBhcnNlcixcbiAgICBzdGF0ZTogU3RhdGUsXG4pID0+IFVuVHlwZWRBU1ROb2RlO1xuXG50eXBlIE91dHB1dDxSZXN1bHQ+ID0gKFxuICAgIG5vZGU6IEFTVE5vZGUsXG4gICAgc3RhdGU/OiA/U3RhdGVcbikgPT4gUmVzdWx0O1xuXG50eXBlIE5vZGVPdXRwdXQ8UmVzdWx0PiA9IChcbiAgICBub2RlOiBTaW5nbGVBU1ROb2RlLFxuICAgIG5lc3RlZE91dHB1dDogT3V0cHV0PFJlc3VsdD4sXG4gICAgc3RhdGU6IFN0YXRlXG4pID0+IFJlc3VsdDtcblxudHlwZSBBcnJheU5vZGVPdXRwdXQ8UmVzdWx0PiA9IChcbiAgICBub2RlOiBBcnJheTxTaW5nbGVBU1ROb2RlPixcbiAgICBuZXN0ZWRPdXRwdXQ6IE91dHB1dDxSZXN1bHQ+LFxuICAgIHN0YXRlOiBTdGF0ZVxuKSA9PiBSZXN1bHQ7XG5cbnR5cGUgUmVhY3RPdXRwdXQgPSBPdXRwdXQ8UmVhY3RFbGVtZW50cz47XG50eXBlIFJlYWN0Tm9kZU91dHB1dCA9IE5vZGVPdXRwdXQ8UmVhY3RFbGVtZW50cz47XG50eXBlIEh0bWxPdXRwdXQgPSBPdXRwdXQ8c3RyaW5nPjtcbnR5cGUgSHRtbE5vZGVPdXRwdXQgPSBOb2RlT3V0cHV0PHN0cmluZz47XG5cbnR5cGUgUGFyc2VyUnVsZSA9IHtcbiAgICArb3JkZXI6IG51bWJlcixcbiAgICArbWF0Y2g6IE1hdGNoRnVuY3Rpb24sXG4gICAgK3F1YWxpdHk/OiAoY2FwdHVyZTogQ2FwdHVyZSwgc3RhdGU6IFN0YXRlLCBwcmV2Q2FwdHVyZTogc3RyaW5nKSA9PiBudW1iZXIsXG4gICAgK3BhcnNlOiBQYXJzZUZ1bmN0aW9uLFxufTtcblxudHlwZSBTaW5nbGVOb2RlUGFyc2VyUnVsZSA9IHtcbiAgICArb3JkZXI6IG51bWJlcixcbiAgICArbWF0Y2g6IE1hdGNoRnVuY3Rpb24sXG4gICAgK3F1YWxpdHk/OiAoY2FwdHVyZTogQ2FwdHVyZSwgc3RhdGU6IFN0YXRlLCBwcmV2Q2FwdHVyZTogc3RyaW5nKSA9PiBudW1iZXIsXG4gICAgK3BhcnNlOiBTaW5nbGVOb2RlUGFyc2VGdW5jdGlvbixcbn07XG5cbnR5cGUgUmVhY3RPdXRwdXRSdWxlID0ge1xuICAgIC8vIHdlIGFsbG93IG51bGwgYmVjYXVzZSBzb21lIHJ1bGVzIGFyZSBuZXZlciBvdXRwdXQgcmVzdWx0cywgYW5kIHRoYXQnc1xuICAgIC8vIGxlZ2FsIGFzIGxvbmcgYXMgbm8gcGFyc2VycyByZXR1cm4gYW4gQVNUIG5vZGUgbWF0Y2hpbmcgdGhhdCBydWxlLlxuICAgIC8vIFdlIGRvbid0IHVzZSA/IGJlY2F1c2UgdGhpcyBtYWtlcyBpdCBiZSBleHBsaWNpdGx5IGRlZmluZWQgYXMgZWl0aGVyXG4gICAgLy8gYSB2YWxpZCBmdW5jdGlvbiBvciBudWxsLCBzbyBpdCBjYW4ndCBiZSBmb3Jnb3R0ZW4uXG4gICAgK3JlYWN0OiBSZWFjdE5vZGVPdXRwdXQgfCBudWxsLFxufTtcblxudHlwZSBIdG1sT3V0cHV0UnVsZSA9IHtcbiAgICAraHRtbDogSHRtbE5vZGVPdXRwdXQgfCBudWxsLFxufTtcblxudHlwZSBBcnJheVJ1bGUgPSB7XG4gICAgK3JlYWN0PzogQXJyYXlOb2RlT3V0cHV0PFJlYWN0RWxlbWVudHM+LFxuICAgICtodG1sPzogQXJyYXlOb2RlT3V0cHV0PHN0cmluZz4sXG4gICAgK1tzdHJpbmddOiBBcnJheU5vZGVPdXRwdXQ8YW55Pixcbn07XG5cbnR5cGUgUGFyc2VyUnVsZXMgPSB7XG4gICAgK0FycmF5PzogQXJyYXlSdWxlLFxuICAgICtbdHlwZTogc3RyaW5nXTogUGFyc2VyUnVsZSxcbn07XG5cbnR5cGUgT3V0cHV0UnVsZXM8UnVsZT4gPSB7XG4gICAgK0FycmF5PzogQXJyYXlSdWxlLFxuICAgICtbdHlwZTogc3RyaW5nXTogUnVsZVxufTtcbnR5cGUgUnVsZXM8T3V0cHV0UnVsZT4gPSB7XG4gICAgK0FycmF5PzogQXJyYXlSdWxlLFxuICAgICtbdHlwZTogc3RyaW5nXTogUGFyc2VyUnVsZSAmIE91dHB1dFJ1bGUsXG59O1xudHlwZSBSZWFjdFJ1bGVzID0ge1xuICAgICtBcnJheT86IHtcbiAgICAgICAgK3JlYWN0OiBBcnJheU5vZGVPdXRwdXQ8UmVhY3RFbGVtZW50cz4sXG4gICAgfSxcbiAgICArW3R5cGU6IHN0cmluZ106IFBhcnNlclJ1bGUgJiBSZWFjdE91dHB1dFJ1bGUsXG59O1xudHlwZSBIdG1sUnVsZXMgPSB7XG4gICAgK0FycmF5Pzoge1xuICAgICAgICAraHRtbDogQXJyYXlOb2RlT3V0cHV0PHN0cmluZz4sXG4gICAgfSxcbiAgICArW3R5cGU6IHN0cmluZ106IFBhcnNlclJ1bGUgJiBIdG1sT3V0cHV0UnVsZSxcbn07XG5cbi8vIFdlIHdhbnQgdG8gY2xhcmlmeSBvdXIgZGVmYXVsdFJ1bGVzIHR5cGVzIGEgbGl0dGxlIGJpdCBtb3JlIHNvIGNsaWVudHMgY2FuXG4vLyByZXVzZSBkZWZhdWx0UnVsZXMgYnVpbHQtaW5zLiBTbyB3ZSBtYWtlIHNvbWUgc3Ryb25nZXIgZ3VhcmFudGVzcyB3aGVuXG4vLyB3ZSBjYW46XG50eXBlIE5vbk51bGxSZWFjdE91dHB1dFJ1bGUgPSB7XG4gICAgK3JlYWN0OiBSZWFjdE5vZGVPdXRwdXQsXG59O1xudHlwZSBFbGVtZW50UmVhY3RPdXRwdXRSdWxlID0ge1xuICAgICtyZWFjdDogTm9kZU91dHB1dDxSZWFjdEVsZW1lbnQ+LFxufTtcbnR5cGUgVGV4dFJlYWN0T3V0cHV0UnVsZSA9IHtcbiAgICArcmVhY3Q6IE5vZGVPdXRwdXQ8c3RyaW5nPixcbn07XG50eXBlIE5vbk51bGxIdG1sT3V0cHV0UnVsZSA9IHtcbiAgICAraHRtbDogSHRtbE5vZGVPdXRwdXQsXG59O1xuXG50eXBlIERlZmF1bHRJblJ1bGUgPSBTaW5nbGVOb2RlUGFyc2VyUnVsZSAmIFJlYWN0T3V0cHV0UnVsZSAmIEh0bWxPdXRwdXRSdWxlO1xudHlwZSBUZXh0SW5PdXRSdWxlID0gU2luZ2xlTm9kZVBhcnNlclJ1bGUgJiBUZXh0UmVhY3RPdXRwdXRSdWxlICYgTm9uTnVsbEh0bWxPdXRwdXRSdWxlO1xudHlwZSBMZW5pZW50SW5PdXRSdWxlID0gU2luZ2xlTm9kZVBhcnNlclJ1bGUgJiBOb25OdWxsUmVhY3RPdXRwdXRSdWxlICYgTm9uTnVsbEh0bWxPdXRwdXRSdWxlO1xudHlwZSBEZWZhdWx0SW5PdXRSdWxlID0gU2luZ2xlTm9kZVBhcnNlclJ1bGUgJiBFbGVtZW50UmVhY3RPdXRwdXRSdWxlICYgTm9uTnVsbEh0bWxPdXRwdXRSdWxlO1xuXG50eXBlIERlZmF1bHRSdWxlcyA9IHtcbiAgICArQXJyYXk6IHtcbiAgICAgICAgK3JlYWN0OiBBcnJheU5vZGVPdXRwdXQ8UmVhY3RFbGVtZW50cz4sXG4gICAgICAgICtodG1sOiBBcnJheU5vZGVPdXRwdXQ8c3RyaW5nPlxuICAgIH0sXG4gICAgK2hlYWRpbmc6IERlZmF1bHRJbk91dFJ1bGUsXG4gICAgK25wdGFibGU6IERlZmF1bHRJblJ1bGUsXG4gICAgK2xoZWFkaW5nOiBEZWZhdWx0SW5SdWxlLFxuICAgICtocjogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArY29kZUJsb2NrOiBEZWZhdWx0SW5PdXRSdWxlLFxuICAgICtmZW5jZTogRGVmYXVsdEluUnVsZSxcbiAgICArYmxvY2tRdW90ZTogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArbGlzdDogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArZGVmOiBMZW5pZW50SW5PdXRSdWxlLFxuICAgICt0YWJsZTogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArdGFibGVTZXBhcmF0b3I6IERlZmF1bHRJblJ1bGUsXG4gICAgK25ld2xpbmU6IFRleHRJbk91dFJ1bGUsXG4gICAgK3BhcmFncmFwaDogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArZXNjYXBlOiBEZWZhdWx0SW5SdWxlLFxuICAgICthdXRvbGluazogRGVmYXVsdEluUnVsZSxcbiAgICArbWFpbHRvOiBEZWZhdWx0SW5SdWxlLFxuICAgICt1cmw6IERlZmF1bHRJblJ1bGUsXG4gICAgK2xpbms6IERlZmF1bHRJbk91dFJ1bGUsXG4gICAgK2ltYWdlOiBEZWZhdWx0SW5PdXRSdWxlLFxuICAgICtyZWZsaW5rOiBEZWZhdWx0SW5SdWxlLFxuICAgICtyZWZpbWFnZTogRGVmYXVsdEluUnVsZSxcbiAgICArZW06IERlZmF1bHRJbk91dFJ1bGUsXG4gICAgK3N0cm9uZzogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArdTogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArZGVsOiBEZWZhdWx0SW5PdXRSdWxlLFxuICAgICtpbmxpbmVDb2RlOiBEZWZhdWx0SW5PdXRSdWxlLFxuICAgICticjogRGVmYXVsdEluT3V0UnVsZSxcbiAgICArdGV4dDogVGV4dEluT3V0UnVsZSxcbn07XG5cbnR5cGUgUmVmTm9kZSA9IHtcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgY29udGVudD86IEFTVE5vZGUsXG4gICAgdGFyZ2V0Pzogc3RyaW5nLFxuICAgIHRpdGxlPzogc3RyaW5nLFxuICAgIGFsdD86IHN0cmluZyxcbn07XG5cbi8vIEVuZCBGbG93IERlZmluaXRpb25zXG4qL1xuXG52YXIgQ1JfTkVXTElORV9SID0gL1xcclxcbj8vZztcbnZhciBUQUJfUiA9IC9cXHQvZztcbnZhciBGT1JNRkVFRF9SID0gL1xcZi9nO1xuXG4vKipcbiAqIFR1cm4gdmFyaW91cyB3aGl0ZXNwYWNlIGludG8gZWFzeS10by1wcm9jZXNzIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBwcmVwcm9jZXNzID0gZnVuY3Rpb24oc291cmNlIC8qIDogc3RyaW5nICovKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKENSX05FV0xJTkVfUiwgJ1xcbicpXG4gICAgICAgICAgICAucmVwbGFjZShGT1JNRkVFRF9SLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKFRBQl9SLCAnICAgICcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLk9wdGlvbmFsU3RhdGV9IGdpdmVuU3RhdGVcbiAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uT3B0aW9uYWxTdGF0ZX0gZGVmYXVsdFN0YXRlXG4gKiBAcmV0dXJucyB7U2ltcGxlTWFya2Rvd24uU3RhdGV9XG4gKi9cbnZhciBwb3B1bGF0ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uKFxuICAgIGdpdmVuU3RhdGUgLyogOiA/U3RhdGUgKi8sXG4gICAgZGVmYXVsdFN0YXRlIC8qIDogP1N0YXRlICovXG4pIC8qIDogU3RhdGUgKi97XG4gICAgdmFyIHN0YXRlIC8qIDogU3RhdGUgKi8gPSBnaXZlblN0YXRlIHx8IHt9O1xuICAgIGlmIChkZWZhdWx0U3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0U3RhdGUsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVbcHJvcF0gPSBkZWZhdWx0U3RhdGVbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGZvciBhIGdpdmVuIHNldCBvZiBydWxlcywgd2l0aCB0aGUgcHJlY2VkZW5jZVxuICogc3BlY2lmaWVkIGFzIGEgbGlzdCBvZiBydWxlcy5cbiAqXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlBhcnNlclJ1bGVzfSBydWxlc1xuICogICAgIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgICAgcnVsZSB0eXBlIC0+IHttYXRjaCwgb3JkZXIsIHBhcnNlfSBvYmplY3RzXG4gKiAgICAgKGxvd2VyIG9yZGVyIGlzIGhpZ2hlciBwcmVjZWRlbmNlKVxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5PcHRpb25hbFN0YXRlfSBbZGVmYXVsdFN0YXRlXVxuICpcbiAqIEByZXR1cm5zIHtTaW1wbGVNYXJrZG93bi5QYXJzZXJ9XG4gKiAgICAgVGhlIHJlc3VsdGluZyBwYXJzZSBmdW5jdGlvbiwgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKiAgICAgQHNvdXJjZTogdGhlIGlucHV0IHNvdXJjZSBzdHJpbmcgdG8gYmUgcGFyc2VkXG4gKiAgICAgQHN0YXRlOiBhbiBvcHRpb25hbCBvYmplY3QgdG8gYmUgdGhyZWFkZWQgdGhyb3VnaCBwYXJzZVxuICogICAgICAgICBjYWxscy4gQWxsb3dzIGNsaWVudHMgdG8gYWRkIHN0YXRlZnVsIG9wZXJhdGlvbnMgdG9cbiAqICAgICAgICAgcGFyc2luZywgc3VjaCBhcyBrZWVwaW5nIHRyYWNrIG9mIGhvdyBtYW55IGxldmVscyBkZWVwXG4gKiAgICAgICAgIHNvbWUgbmVzdGluZyBpcy4gRm9yIGFuIGV4YW1wbGUgdXNlLWNhc2UsIHNlZSBwYXNzYWdlLXJlZlxuICogICAgICAgICBwYXJzaW5nIGluIHNyYy93aWRnZXRzL3Bhc3NhZ2UvcGFzc2FnZS1tYXJrZG93bi5qc3hcbiAqL1xudmFyIHBhcnNlckZvciA9IGZ1bmN0aW9uKHJ1bGVzIC8qOiBQYXJzZXJSdWxlcyAqLywgZGVmYXVsdFN0YXRlIC8qOiA/U3RhdGUgKi8pIHtcbiAgICAvLyBTb3J0cyBydWxlcyBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIG9yZGVyLCB0aGVuXG4gICAgLy8gYXNjZW5kaW5nIHJ1bGUgbmFtZSBpbiBjYXNlIG9mIHRpZXMuXG4gICAgdmFyIHJ1bGVMaXN0ID0gT2JqZWN0LmtleXMocnVsZXMpLmZpbHRlcihmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBydWxlID0gcnVsZXNbdHlwZV07XG4gICAgICAgIGlmIChydWxlID09IG51bGwgfHwgcnVsZS5tYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gcnVsZS5vcmRlcjtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb3JkZXIgIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShvcmRlcikpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJzaW1wbGUtbWFya2Rvd246IEludmFsaWQgb3JkZXIgZm9yIHJ1bGUgYFwiICsgdHlwZSArIFwiYDogXCIgK1xuICAgICAgICAgICAgICAgIFN0cmluZyhvcmRlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBydWxlTGlzdC5zb3J0KGZ1bmN0aW9uKHR5cGVBLCB0eXBlQikge1xuICAgICAgICB2YXIgcnVsZUEgLyogOiBQYXJzZXJSdWxlICovID0gLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5QYXJzZXJSdWxlfSAqLyAocnVsZXNbdHlwZUFdIC8qOjogOmFueSAqLyk7XG4gICAgICAgIHZhciBydWxlQiAvKiA6IFBhcnNlclJ1bGUgKi8gPSAvKiogQHR5cGUge1NpbXBsZU1hcmtkb3duLlBhcnNlclJ1bGV9ICovIChydWxlc1t0eXBlQl0gLyo6OiA6YW55ICovKTtcbiAgICAgICAgdmFyIG9yZGVyQSA9IHJ1bGVBLm9yZGVyO1xuICAgICAgICB2YXIgb3JkZXJCID0gcnVsZUIub3JkZXI7XG5cbiAgICAgICAgLy8gRmlyc3Qgc29ydCBiYXNlZCBvbiBpbmNyZWFzaW5nIG9yZGVyXG4gICAgICAgIGlmIChvcmRlckEgIT09IG9yZGVyQikge1xuICAgICAgICAgICAgcmV0dXJuIG9yZGVyQSAtIG9yZGVyQjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRhcnlPcmRlckEgPSBydWxlQS5xdWFsaXR5ID8gMCA6IDE7XG4gICAgICAgIHZhciBzZWNvbmRhcnlPcmRlckIgPSBydWxlQi5xdWFsaXR5ID8gMCA6IDE7XG5cbiAgICAgICAgaWYgKHNlY29uZGFyeU9yZGVyQSAhPT0gc2Vjb25kYXJ5T3JkZXJCKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Vjb25kYXJ5T3JkZXJBIC0gc2Vjb25kYXJ5T3JkZXJCO1xuXG4gICAgICAgIC8vIFRoZW4gYmFzZWQgb24gaW5jcmVhc2luZyB1bmljb2RlIGxleGljb2dyYXBoaWMgb3JkZXJpbmdcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlQSA8IHR5cGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZUEgPiB0eXBlQikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJ1bGVzIHNob3VsZCBuZXZlciBoYXZlIHRoZSBzYW1lIG5hbWUsXG4gICAgICAgICAgICAvLyBidXQgdGhpcyBpcyBwcm92aWRlZCBmb3IgY29tcGxldGVuZXNzLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uU3RhdGV9ICovXG4gICAgdmFyIGxhdGVzdFN0YXRlO1xuICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uUGFyc2VyfSAqL1xuICAgIHZhciBuZXN0ZWRQYXJzZSA9IGZ1bmN0aW9uKHNvdXJjZSAvKiA6IHN0cmluZyAqLywgc3RhdGUgLyogOiA/U3RhdGUgKi8pIHtcbiAgICAgICAgLyoqIEB0eXBlIEFycmF5PFNpbXBsZU1hcmtkb3duLlNpbmdsZUFTVE5vZGU+ICovXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgc3RhdGUgPSBzdGF0ZSB8fCBsYXRlc3RTdGF0ZTtcbiAgICAgICAgbGF0ZXN0U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGJlc3QgbWF0Y2gsIGl0J3MgcnVsZSwgYW5kIHF1YWxpdHk6XG4gICAgICAgICAgICB2YXIgcnVsZVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHF1YWxpdHkgPSBOYU47XG5cbiAgICAgICAgICAgIC8vIGxvb3AgY29udHJvbCB2YXJpYWJsZXM6XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgY3VyclJ1bGVUeXBlID0gcnVsZUxpc3RbMF07XG4gICAgICAgICAgICB2YXIgY3VyclJ1bGUgLyogOiBQYXJzZXJSdWxlICovID0gLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5QYXJzZXJSdWxlfSAqLyAoIHJ1bGVzW2N1cnJSdWxlVHlwZV0gLyo6OiA6YW55ICovICk7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyck9yZGVyID0gY3VyclJ1bGUub3JkZXI7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZDYXB0dXJlU3RyID0gc3RhdGUucHJldkNhcHR1cmUgPT0gbnVsbCA/IFwiXCIgOiBzdGF0ZS5wcmV2Q2FwdHVyZVswXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckNhcHR1cmUgPSBjdXJyUnVsZS5tYXRjaChzb3VyY2UsIHN0YXRlLCBwcmV2Q2FwdHVyZVN0cik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VyckNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJRdWFsaXR5ID0gY3VyclJ1bGUucXVhbGl0eSA/IGN1cnJSdWxlLnF1YWxpdHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNhcHR1cmVTdHJcbiAgICAgICAgICAgICAgICAgICAgKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGFsd2F5cyBiZSB0cnVlIHRoZSBmaXJzdCB0aW1lIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgcXVhbGl0eSBpcyBOYU4gKHRoYXQncyB3aHkgdGhlcmUncyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uZGl0aW9uIG5lZ2F0aW9uKS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY3VyclF1YWxpdHkgPD0gcXVhbGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVUeXBlID0gY3VyclJ1bGVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZSA9IGN1cnJSdWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZSA9IGN1cnJDYXB0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbGl0eSA9IGN1cnJRdWFsaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTW92ZSBvbiB0byB0aGUgbmV4dCBpdGVtLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1ha2VzIGBjdXJyUnVsZWAgYmUgdGhlIG5leHQgaXRlbVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjdXJyUnVsZVR5cGUgPSBydWxlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBjdXJyUnVsZSA9IC8qOjooKCovIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uUGFyc2VyUnVsZX0gKi8gKHJ1bGVzW2N1cnJSdWxlVHlwZV0pIC8qOjogOiBhbnkpIDogUGFyc2VyUnVsZSkqLztcblxuICAgICAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBsb29waW5nIHdoaWxlIHdlJ3JlIHN0aWxsIHdpdGhpbiB0aGUgcnVsZUxpc3RcbiAgICAgICAgICAgICAgICBjdXJyUnVsZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBtYXRjaCB5ZXQsIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICFjYXB0dXJlIHx8IChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIHdlIGhhdmUgYSBtYXRjaCwgYnV0IHRoZSBuZXh0IHJ1bGUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIG9yZGVyLCBhbmQgaGFzIGEgcXVhbGl0eSBtZWFzdXJlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25zLCB0aGVuIHRoaXMgcnVsZSBtdXN0IGhhdmUgYSBxdWFsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFzdXJlbWVudCBmdW5jdGlvbiAoc2luY2UgdGhleSBhcmUgc29ydGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhvc2Ugd2l0aG91dCksIGFuZCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGJldHRlciBxdWFsaXR5IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyUnVsZS5vcmRlciA9PT0gY3Vyck9yZGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyUnVsZS5xdWFsaXR5XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBUT0RPKGFyaWEpOiBXcml0ZSB0ZXN0cyBmb3IgdGhlc2VcbiAgICAgICAgICAgIGlmIChydWxlID09IG51bGwgfHwgY2FwdHVyZSA9PSBudWxsIC8qOjogfHwgcnVsZVR5cGUgPT0gbnVsbCAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJ1bGUgZm9yIHRoZSBiZWxvdyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGVudC4gVGhlIHJ1bGUgd2l0aCBoaWdoZXN0IGBvcmRlcmAgc2hvdWxkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhbHdheXMgbWF0Y2ggY29udGVudCBwcm92aWRlZCB0byBpdC4gQ2hlY2sgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInRoZSBkZWZpbml0aW9uIG9mIGBtYXRjaGAgZm9yICdcIiArXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVMaXN0W3J1bGVMaXN0Lmxlbmd0aCAtIDFdICtcbiAgICAgICAgICAgICAgICAgICAgXCInLiBJdCBzZWVtcyB0byBub3QgbWF0Y2ggdGhlIGZvbGxvd2luZyBzb3VyY2U6XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcHR1cmUuaW5kZXgpIHsgLy8gSWYgcHJlc2VudCBhbmQgbm9uLXplcm8sIGkuZS4gYSBub24tXiByZWdleHAgcmVzdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJgbWF0Y2hgIG11c3QgcmV0dXJuIGEgY2FwdHVyZSBzdGFydGluZyBhdCBpbmRleCAwIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIodGhlIGN1cnJlbnQgcGFyc2UgaW5kZXgpLiBEaWQgeW91IGZvcmdldCBhIF4gYXQgdGhlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzdGFydCBvZiB0aGUgUmVnRXhwP1wiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHJ1bGUucGFyc2UoY2FwdHVyZSwgbmVzdGVkUGFyc2UsIHN0YXRlKTtcbiAgICAgICAgICAgIC8vIFdlIG1haW50YWluIHRoZSBzYW1lIG9iamVjdCBoZXJlIHNvIHRoYXQgcnVsZXMgY2FuXG4gICAgICAgICAgICAvLyBzdG9yZSByZWZlcmVuY2VzIHRvIHRoZSBvYmplY3RzIHRoZXkgcmV0dXJuIGFuZFxuICAgICAgICAgICAgLy8gbW9kaWZ5IHRoZW0gbGF0ZXIuIChvb3BzIHNvcnJ5ISBidXQgdGhpcyBhZGRzIGEgbG90XG4gICAgICAgICAgICAvLyBvZiBwb3dlci0tc2VlIHJlZmxpbmtzLilcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIHBhcnNlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbGV0IHJ1bGVzIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHR5cGUgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGVpciBwYXJzZWQgbm9kZSBpZiB0aGV5IHdvdWxkIGxpa2UgdG8sIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBjYW4gYmUgYSBzaW5nbGUgb3V0cHV0IGZ1bmN0aW9uIGZvciBhbGwgbGlua3MsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGVyZSBhcmUgc2V2ZXJhbCBydWxlcyB0byBwYXJzZSB0aGVtLlxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQudHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC50eXBlID0gcnVsZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uU2luZ2xlQVNUTm9kZX0gKi8gKHBhcnNlZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5wcmV2Q2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXRlLnByZXZDYXB0dXJlWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5QYXJzZXJ9ICovXG4gICAgdmFyIG91dGVyUGFyc2UgPSBmdW5jdGlvbihzb3VyY2UgLyogOiBzdHJpbmcgKi8sIHN0YXRlIC8qIDogP1N0YXRlICovKSB7XG4gICAgICAgIGxhdGVzdFN0YXRlID0gcG9wdWxhdGVJbml0aWFsU3RhdGUoc3RhdGUsIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIGlmICghbGF0ZXN0U3RhdGUuaW5saW5lICYmICFsYXRlc3RTdGF0ZS5kaXNhYmxlQXV0b0Jsb2NrTmV3bGluZXMpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZSArIFwiXFxuXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIHByZXZpb3VzIGNhcHR1cmUgc28gdGhhdCBtYXRjaCBmdW5jdGlvbnMgY2FuXG4gICAgICAgIC8vIHVzZSBzb21lIGxpbWl0ZWQgYW1vdW50IG9mIGxvb2tiZWhpbmQuIExpc3RzIHVzZSB0aGlzIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGV5IGRvbid0IG1hdGNoIGFyYml0cmFyeSAnLSAnIG9yICcqICcgaW4gaW5saW5lXG4gICAgICAgIC8vIHRleHQgKHNlZSB0aGUgbGlzdCBydWxlIGZvciBtb3JlIGluZm9ybWF0aW9uKS4gVGhpcyBzdG9yZXNcbiAgICAgICAgLy8gdGhlIGZ1bGwgcmVnZXggY2FwdHVyZSBvYmplY3QsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAgbGF0ZXN0U3RhdGUucHJldkNhcHR1cmUgPSBudWxsO1xuICAgICAgICByZXR1cm4gbmVzdGVkUGFyc2UocHJlcHJvY2Vzcyhzb3VyY2UpLCBsYXRlc3RTdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gb3V0ZXJQYXJzZTtcbn07XG5cbi8vIENyZWF0ZXMgYSBtYXRjaCBmdW5jdGlvbiBmb3IgYW4gaW5saW5lIHNjb3BlZCBlbGVtZW50IGZyb20gYSByZWdleFxuLyoqIEB0eXBlIHsocmVnZXg6IFJlZ0V4cCkgPT4gU2ltcGxlTWFya2Rvd24uTWF0Y2hGdW5jdGlvbn0gKi9cbnZhciBpbmxpbmVSZWdleCA9IGZ1bmN0aW9uKHJlZ2V4IC8qIDogUmVnRXhwICovKSB7XG4gICAgLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5NYXRjaEZ1bmN0aW9ufSAqL1xuICAgIHZhciBtYXRjaCAvKiA6IE1hdGNoRnVuY3Rpb24gKi8gPSBmdW5jdGlvbihzb3VyY2UsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleC5leGVjKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWF0Y2gucmVnZXggPSByZWdleDtcbiAgICByZXR1cm4gbWF0Y2g7XG59O1xuXG4vLyBDcmVhdGVzIGEgbWF0Y2ggZnVuY3Rpb24gZm9yIGEgYmxvY2sgc2NvcGVkIGVsZW1lbnQgZnJvbSBhIHJlZ2V4XG4vKiogQHR5cGUgeyhyZWdleDogUmVnRXhwKSA9PiBTaW1wbGVNYXJrZG93bi5NYXRjaEZ1bmN0aW9ufSAqL1xudmFyIGJsb2NrUmVnZXggPSBmdW5jdGlvbihyZWdleCAvKiA6IFJlZ0V4cCAqLykge1xuICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uTWF0Y2hGdW5jdGlvbn0gKi9cbiAgICB2YXIgbWF0Y2ggLyogOiBNYXRjaEZ1bmN0aW9uICovID0gZnVuY3Rpb24oc291cmNlLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleC5leGVjKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1hdGNoLnJlZ2V4ID0gcmVnZXg7XG4gICAgcmV0dXJuIG1hdGNoO1xufTtcblxuLy8gQ3JlYXRlcyBhIG1hdGNoIGZ1bmN0aW9uIGZyb20gYSByZWdleCwgaWdub3JpbmcgYmxvY2svaW5saW5lIHNjb3BlXG4vKiogQHR5cGUgeyhyZWdleDogUmVnRXhwKSA9PiBTaW1wbGVNYXJrZG93bi5NYXRjaEZ1bmN0aW9ufSAqL1xudmFyIGFueVNjb3BlUmVnZXggPSBmdW5jdGlvbihyZWdleCAvKiA6IFJlZ0V4cCAqLykge1xuICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uTWF0Y2hGdW5jdGlvbn0gKi9cbiAgICB2YXIgbWF0Y2ggLyogOiBNYXRjaEZ1bmN0aW9uICovID0gZnVuY3Rpb24oc291cmNlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gcmVnZXguZXhlYyhzb3VyY2UpO1xuICAgIH07XG4gICAgbWF0Y2gucmVnZXggPSByZWdleDtcbiAgICByZXR1cm4gbWF0Y2g7XG59O1xuXG52YXIgVFlQRV9TWU1CT0wgPVxuICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IgJiZcbiAgICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gcHJvcHNcbiAqIEByZXR1cm5zIHtTaW1wbGVNYXJrZG93bi5SZWFjdEVsZW1lbnR9XG4gKi9cbnZhciByZWFjdEVsZW1lbnQgPSBmdW5jdGlvbihcbiAgICB0eXBlIC8qIDogc3RyaW5nICovLFxuICAgIGtleSAvKiA6IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCB2b2lkICovLFxuICAgIHByb3BzIC8qIDogeyBbc3RyaW5nXTogYW55IH0gKi9cbikgLyogOiBSZWFjdEVsZW1lbnQgKi8ge1xuICAgIHZhciBlbGVtZW50IC8qIDogUmVhY3RFbGVtZW50ICovID0gLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5SZWFjdEVsZW1lbnR9ICovICh7XG4gICAgICAgICQkdHlwZW9mOiBUWVBFX1NZTUJPTCxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXkgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGtleSxcbiAgICAgICAgcmVmOiBudWxsLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogbnVsbFxuICAgIH0gLyogOiBhbnkgKi8pO1xuICAgIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqIFJldHVybnMgYSBjbG9zZWQgSFRNTCB0YWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAtIE5hbWUgb2YgSFRNTCB0YWcgKGVnLiBcImVtXCIgb3IgXCJhXCIpXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIElubmVyIGNvbnRlbnQgb2YgdGFnXG4gKiBAcGFyYW0ge3sgW2F0dHI6IHN0cmluZ106IFNpbXBsZU1hcmtkb3duLkF0dHIgfX0gW2F0dHJpYnV0ZXNdIC0gT3B0aW9uYWwgZXh0cmEgYXR0cmlidXRlcyBvZiB0YWcgYXMgYW4gb2JqZWN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICogICBlZy4geyBcImhyZWZcIjogXCJodHRwOi8vZ29vZ2xlLmNvbVwiIH0uIEZhbHNleSBhdHRyaWJ1dGVzIGFyZSBmaWx0ZXJlZCBvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Nsb3NlZF0gLSBib29sZWFuIHRoYXQgY29udHJvbHMgd2hldGhlciB0YWcgaXMgY2xvc2VkIG9yIG5vdCAoZWcuIGltZyB0YWdzKS5cbiAqICAgZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG52YXIgaHRtbFRhZyA9IGZ1bmN0aW9uKFxuICAgIHRhZ05hbWUgLyogOiBzdHJpbmcgKi8sXG4gICAgY29udGVudCAvKiA6IHN0cmluZyAqLyxcbiAgICBhdHRyaWJ1dGVzIC8qIDogP3tbYW55XTogP0F0dHJ9ICovLFxuICAgIGlzQ2xvc2VkIC8qIDogP2Jvb2xlYW4gKi9cbikge1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlzQ2xvc2VkID0gdHlwZW9mIGlzQ2xvc2VkICE9PSAndW5kZWZpbmVkJyA/IGlzQ2xvc2VkIDogdHJ1ZTtcblxuICAgIHZhciBhdHRyaWJ1dGVTdHJpbmcgPSBcIlwiO1xuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgLy8gUmVtb3ZlcyBmYWxzZXkgYXR0cmlidXRlc1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpICYmXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVTdHJpbmcgKz0gXCIgXCIgK1xuICAgICAgICAgICAgICAgIHNhbml0aXplVGV4dChhdHRyKSArICc9XCInICtcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZVRleHQoYXR0cmlidXRlKSArICdcIic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5jbG9zZWRUYWcgPSBcIjxcIiArIHRhZ05hbWUgKyBhdHRyaWJ1dGVTdHJpbmcgKyBcIj5cIjtcblxuICAgIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm4gdW5jbG9zZWRUYWcgKyBjb250ZW50ICsgXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmNsb3NlZFRhZztcbiAgICB9XG59O1xuXG52YXIgRU1QVFlfUFJPUFMgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHVybCAtIHVybCB0byBzYW5pdGl6ZVxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IC0gdXJsIGlmIHNhZmUsIG9yIG51bGwgaWYgYSBzYWZlIHVybCBjb3VsZCBub3QgYmUgbWFkZVxuICovXG52YXIgc2FuaXRpemVVcmwgPSBmdW5jdGlvbih1cmwgLyogOiA/c3RyaW5nICovKSB7XG4gICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmwpXG4gICAgICAgICAgICAucmVwbGFjZSgvW15BLVphLXowLTkvOl0vZywgJycpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRlY29kZVVSSUNvbXBvbmVudCBzb21ldGltZXMgdGhyb3dzIGEgVVJJRXJyb3JcbiAgICAgICAgLy8gU2VlIGBkZWNvZGVVUklDb21wb25lbnQoJ2ElQUZjJyk7YFxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzkwNjQ1MzYvamF2YXNjcmlwdC1kZWNvZGV1cmljb21wb25lbnQtbWFsZm9ybWVkLXVyaS1leGNlcHRpb25cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuXG52YXIgU0FOSVRJWkVfVEVYVF9SID0gL1s8PiZcIiddL2c7XG4vKiogQHR5cGUge2FueX0gKi9cbnZhciBTQU5JVElaRV9URVhUX0NPREVTID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICcmJzogJyZhbXA7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJy8nOiAnJiN4MkY7JyxcbiAgICBcImBcIjogJyYjOTY7J1xufTtcbi8qKlxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5BdHRyfSB0ZXh0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgc2FuaXRpemVUZXh0ID0gZnVuY3Rpb24odGV4dCAvKiA6IEF0dHIgKi8pIHtcbiAgICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoU0FOSVRJWkVfVEVYVF9SLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgICAgcmV0dXJuIFNBTklUSVpFX1RFWFRfQ09ERVNbY2hyXTtcbiAgICB9KTtcbn07XG5cbnZhciBVTkVTQ0FQRV9VUkxfUiA9IC9cXFxcKFteMC05QS1aYS16XFxzXSkvZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3VXJsU3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgdW5lc2NhcGVVcmwgPSBmdW5jdGlvbihyYXdVcmxTdHJpbmcgLyogOiBzdHJpbmcgKi8pIHtcbiAgICByZXR1cm4gcmF3VXJsU3RyaW5nLnJlcGxhY2UoVU5FU0NBUEVfVVJMX1IsIFwiJDFcIik7XG59O1xuXG4vKipcbiAqIFBhcnNlIHNvbWUgY29udGVudCB3aXRoIHRoZSBwYXJzZXIgYHBhcnNlYCwgd2l0aCBzdGF0ZS5pbmxpbmVcbiAqIHNldCB0byB0cnVlLiBVc2VmdWwgZm9yIGJsb2NrIGVsZW1lbnRzOyBub3QgZ2VuZXJhbGx5IG5lY2Vzc2FyeVxuICogdG8gYmUgdXNlZCBieSBpbmxpbmUgZWxlbWVudHMgKHdoZXJlIHN0YXRlLmlubGluZSBpcyBhbHJlYWR5IHRydWUuXG4gKlxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5QYXJzZXJ9IHBhcnNlXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5TdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtTaW1wbGVNYXJrZG93bi5BU1ROb2RlfVxuICovXG52YXIgcGFyc2VJbmxpbmUgPSBmdW5jdGlvbihwYXJzZSwgY29udGVudCwgc3RhdGUpIHtcbiAgICB2YXIgaXNDdXJyZW50bHlJbmxpbmUgPSBzdGF0ZS5pbmxpbmUgfHwgZmFsc2U7XG4gICAgc3RhdGUuaW5saW5lID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2UoY29udGVudCwgc3RhdGUpO1xuICAgIHN0YXRlLmlubGluZSA9IGlzQ3VycmVudGx5SW5saW5lO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlBhcnNlcn0gcGFyc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlN0YXRlfSBzdGF0ZVxuICogQHJldHVybnMge1NpbXBsZU1hcmtkb3duLkFTVE5vZGV9XG4gKi9cbnZhciBwYXJzZUJsb2NrID0gZnVuY3Rpb24ocGFyc2UsIGNvbnRlbnQsIHN0YXRlKSB7XG4gICAgdmFyIGlzQ3VycmVudGx5SW5saW5lID0gc3RhdGUuaW5saW5lIHx8IGZhbHNlO1xuICAgIHN0YXRlLmlubGluZSA9IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSBwYXJzZShjb250ZW50ICsgXCJcXG5cXG5cIiwgc3RhdGUpO1xuICAgIHN0YXRlLmlubGluZSA9IGlzQ3VycmVudGx5SW5saW5lO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uQ2FwdHVyZX0gY2FwdHVyZVxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5QYXJzZXJ9IHBhcnNlXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlN0YXRlfSBzdGF0ZVxuICogQHJldHVybnMge1NpbXBsZU1hcmtkb3duLlVuVHlwZWRBU1ROb2RlfVxuICovXG52YXIgcGFyc2VDYXB0dXJlSW5saW5lID0gZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogcGFyc2VJbmxpbmUocGFyc2UsIGNhcHR1cmVbMV0sIHN0YXRlKVxuICAgIH07XG59O1xuLyoqXG4gKiBAcmV0dXJucyB7U2ltcGxlTWFya2Rvd24uVW5UeXBlZEFTVE5vZGV9XG4gKi9cbnZhciBpZ25vcmVDYXB0dXJlID0gZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfTtcblxuLy8gcmVjb2duaXplIGEgYCpgIGAtYCwgYCtgLCBgMS5gLCBgMi5gLi4uIGxpc3QgYnVsbGV0XG52YXIgTElTVF9CVUxMRVQgPSBcIig/OlsqKy1dfFxcXFxkK1xcXFwuKVwiO1xuLy8gcmVjb2duaXplIHRoZSBzdGFydCBvZiBhIGxpc3QgaXRlbTpcbi8vIGxlYWRpbmcgc3BhY2UgcGx1cyBhIGJ1bGxldCBwbHVzIGEgc3BhY2UgKGAgICAqIGApXG52YXIgTElTVF9JVEVNX1BSRUZJWCA9IFwiKCAqKShcIiArIExJU1RfQlVMTEVUICsgXCIpICtcIjtcbnZhciBMSVNUX0lURU1fUFJFRklYX1IgPSBuZXcgUmVnRXhwKFwiXlwiICsgTElTVF9JVEVNX1BSRUZJWCk7XG4vLyByZWNvZ25pemUgYW4gaW5kaXZpZHVhbCBsaXN0IGl0ZW06XG4vLyAgKiBoaVxuLy8gICAgdGhpcyBpcyBwYXJ0IG9mIHRoZSBzYW1lIGl0ZW1cbi8vXG4vLyAgICBhcyBpcyB0aGlzLCB3aGljaCBpcyBhIG5ldyBwYXJhZ3JhcGggaW4gdGhlIHNhbWUgaXRlbVxuLy9cbi8vICAqIGJ1dCB0aGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIGl0ZW1cbnZhciBMSVNUX0lURU1fUiA9IG5ldyBSZWdFeHAoXG4gICAgTElTVF9JVEVNX1BSRUZJWCArXG4gICAgXCJbXlxcXFxuXSooPzpcXFxcblwiICtcbiAgICBcIig/IVxcXFwxXCIgKyBMSVNUX0JVTExFVCArIFwiIClbXlxcXFxuXSopKihcXG58JClcIixcbiAgICBcImdtXCJcbik7XG52YXIgQkxPQ0tfRU5EX1IgPSAvXFxuezIsfSQvO1xudmFyIElOTElORV9DT0RFX0VTQ0FQRV9CQUNLVElDS1NfUiA9IC9eICg/PSAqYCl8KGAgKikgJC9nO1xuLy8gcmVjb2duaXplIHRoZSBlbmQgb2YgYSBwYXJhZ3JhcGggYmxvY2sgaW5zaWRlIGEgbGlzdCBpdGVtOlxuLy8gdHdvIG9yIG1vcmUgbmV3bGluZXMgYXQgZW5kIGVuZCBvZiB0aGUgaXRlbVxudmFyIExJU1RfQkxPQ0tfRU5EX1IgPSBCTE9DS19FTkRfUjtcbnZhciBMSVNUX0lURU1fRU5EX1IgPSAvICpcXG4rJC87XG4vLyBjaGVjayB3aGV0aGVyIGEgbGlzdCBpdGVtIGhhcyBwYXJhZ3JhcGhzOiBpZiBpdCBkb2VzLFxuLy8gd2UgbGVhdmUgdGhlIG5ld2xpbmVzIGF0IHRoZSBlbmRcbnZhciBMSVNUX1IgPSBuZXcgUmVnRXhwKFxuICAgIFwiXiggKikoXCIgKyBMSVNUX0JVTExFVCArIFwiKSBcIiArXG4gICAgXCJbXFxcXHNcXFxcU10rPyg/OlxcbnsyLH0oPyEgKVwiICtcbiAgICBcIig/IVxcXFwxXCIgKyBMSVNUX0JVTExFVCArIFwiIClcXFxcbipcIiArXG4gICAgLy8gdGhlIFxcXFxzKiQgaGVyZSBpcyBzbyB0aGF0IHdlIGNhbiBwYXJzZSB0aGUgaW5zaWRlIG9mIG5lc3RlZFxuICAgIC8vIGxpc3RzLCB3aGVyZSBvdXIgY29udGVudCBtaWdodCBlbmQgYmVmb3JlIHdlIHJlY2VpdmUgdHdvIGBcXG5gc1xuICAgIFwifFxcXFxzKlxcbiokKVwiXG4pO1xudmFyIExJU1RfTE9PS0JFSElORF9SID0gLyg/Ol58XFxuKSggKikkLztcblxudmFyIFRBQkxFUyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgVEFCTEVfUk9XX1NFUEFSQVRPUl9UUklNID0gL14gKlxcfCAqfCAqXFx8ICokL2c7XG4gICAgdmFyIFRBQkxFX0NFTExfRU5EX1RSSU0gPSAvICokLztcbiAgICB2YXIgVEFCTEVfUklHSFRfQUxJR04gPSAvXiAqLSs6ICokLztcbiAgICB2YXIgVEFCTEVfQ0VOVEVSX0FMSUdOID0gL14gKjotKzogKiQvO1xuICAgIHZhciBUQUJMRV9MRUZUX0FMSUdOID0gL14gKjotKyAqJC87XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ25DYXB0dXJlXG4gICAgICogQHJldHVybnMge1NpbXBsZU1hcmtkb3duLlRhYmxlQWxpZ25tZW50fVxuICAgICAqL1xuICAgIHZhciBwYXJzZVRhYmxlQWxpZ25DYXB0dXJlID0gZnVuY3Rpb24oYWxpZ25DYXB0dXJlKSB7XG4gICAgICAgIGlmIChUQUJMRV9SSUdIVF9BTElHTi50ZXN0KGFsaWduQ2FwdHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoVEFCTEVfQ0VOVEVSX0FMSUdOLnRlc3QoYWxpZ25DYXB0dXJlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoVEFCTEVfTEVGVF9BTElHTi50ZXN0KGFsaWduQ2FwdHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlBhcnNlcn0gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlN0YXRlfSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpbUVuZFNlcGFyYXRvcnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8U2ltcGxlTWFya2Rvd24uVGFibGVBbGlnbm1lbnQ+fVxuICAgICAqL1xuICAgIHZhciBwYXJzZVRhYmxlQWxpZ24gPSBmdW5jdGlvbihzb3VyY2UsIHBhcnNlLCBzdGF0ZSwgdHJpbUVuZFNlcGFyYXRvcnMpIHtcbiAgICAgICAgaWYgKHRyaW1FbmRTZXBhcmF0b3JzKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShUQUJMRV9ST1dfU0VQQVJBVE9SX1RSSU0sIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGlnblRleHQgPSBzb3VyY2UudHJpbSgpLnNwbGl0KFwifFwiKTtcbiAgICAgICAgcmV0dXJuIGFsaWduVGV4dC5tYXAocGFyc2VUYWJsZUFsaWduQ2FwdHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlBhcnNlcn0gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLlN0YXRlfSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpbUVuZFNlcGFyYXRvcnNcbiAgICAgKiBAcmV0dXJucyB7U2ltcGxlTWFya2Rvd24uU2luZ2xlQVNUTm9kZVtdW119XG4gICAgICovXG4gICAgdmFyIHBhcnNlVGFibGVSb3cgPSBmdW5jdGlvbihzb3VyY2UsIHBhcnNlLCBzdGF0ZSwgdHJpbUVuZFNlcGFyYXRvcnMpIHtcbiAgICAgICAgdmFyIHByZXZJblRhYmxlID0gc3RhdGUuaW5UYWJsZTtcbiAgICAgICAgc3RhdGUuaW5UYWJsZSA9IHRydWU7XG4gICAgICAgIHZhciB0YWJsZVJvdyA9IHBhcnNlKHNvdXJjZS50cmltKCksIHN0YXRlKTtcbiAgICAgICAgc3RhdGUuaW5UYWJsZSA9IHByZXZJblRhYmxlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uU2luZ2xlQVNUTm9kZVtdW119ICovXG4gICAgICAgIHZhciBjZWxscyA9IFtbXV07XG4gICAgICAgIHRhYmxlUm93LmZvckVhY2goZnVuY3Rpb24obm9kZSwgaSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhYmxlU2VwYXJhdG9yJykge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgZW1wdHkgdGFibGUgc2VwYXJhdG9ycyBhdCB0aGUgc3RhcnQvZW5kOlxuICAgICAgICAgICAgICAgIGlmICghdHJpbUVuZFNlcGFyYXRvcnMgfHwgaSAhPT0gMCAmJiBpICE9PSB0YWJsZVJvdy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwbGl0IHRoZSBjdXJyZW50IHJvdzpcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAndGV4dCcgJiYgKFxuICAgICAgICAgICAgICAgICAgICB0YWJsZVJvd1tpICsgMV0gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0YWJsZVJvd1tpICsgMV0udHlwZSA9PT0gJ3RhYmxlU2VwYXJhdG9yJ1xuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2UoVEFCTEVfQ0VMTF9FTkRfVFJJTSwgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjZWxscztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uUGFyc2VyfSBwYXJzZVxuICAgICAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uU3RhdGV9IHN0YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0cmltRW5kU2VwYXJhdG9yc1xuICAgICAqIEByZXR1cm5zIHtTaW1wbGVNYXJrZG93bi5BU1ROb2RlW11bXX1cbiAgICAgKi9cbiAgICB2YXIgcGFyc2VUYWJsZUNlbGxzID0gZnVuY3Rpb24oc291cmNlLCBwYXJzZSwgc3RhdGUsIHRyaW1FbmRTZXBhcmF0b3JzKSB7XG4gICAgICAgIHZhciByb3dzVGV4dCA9IHNvdXJjZS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG5cbiAgICAgICAgcmV0dXJuIHJvd3NUZXh0Lm1hcChmdW5jdGlvbihyb3dUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUYWJsZVJvdyhyb3dUZXh0LCBwYXJzZSwgc3RhdGUsIHRyaW1FbmRTZXBhcmF0b3JzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpbUVuZFNlcGFyYXRvcnNcbiAgICAgKiBAcmV0dXJucyB7U2ltcGxlTWFya2Rvd24uU2luZ2xlTm9kZVBhcnNlRnVuY3Rpb259XG4gICAgICovXG4gICAgdmFyIHBhcnNlVGFibGUgPSBmdW5jdGlvbih0cmltRW5kU2VwYXJhdG9ycykge1xuICAgICAgICAvKiogQHR5cGUge1NpbXBsZU1hcmtkb3duLlNpbmdsZU5vZGVQYXJzZUZ1bmN0aW9ufSAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHBhcnNlVGFibGVSb3coY2FwdHVyZVsxXSwgcGFyc2UsIHN0YXRlLCB0cmltRW5kU2VwYXJhdG9ycyk7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSBwYXJzZVRhYmxlQWxpZ24oY2FwdHVyZVsyXSwgcGFyc2UsIHN0YXRlLCB0cmltRW5kU2VwYXJhdG9ycyk7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBwYXJzZVRhYmxlQ2VsbHMoY2FwdHVyZVszXSwgcGFyc2UsIHN0YXRlLCB0cmltRW5kU2VwYXJhdG9ycyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmxpbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgICAgIGNlbGxzOiBjZWxsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2VUYWJsZTogcGFyc2VUYWJsZSh0cnVlKSxcbiAgICAgICAgcGFyc2VOcFRhYmxlOiBwYXJzZVRhYmxlKGZhbHNlKSxcbiAgICAgICAgVEFCTEVfUkVHRVg6IC9eICooXFx8LispXFxuICpcXHwoICpbLTpdK1stfCA6XSopXFxuKCg/OiAqXFx8LiooPzpcXG58JCkpKilcXG4qLyxcbiAgICAgICAgTlBUQUJMRV9SRUdFWDogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbiAgICB9O1xufSkoKTtcblxudmFyIExJTktfSU5TSURFID0gXCIoPzpcXFxcW1teXFxcXF1dKlxcXFxdfFteXFxcXFtcXFxcXV18XFxcXF0oPz1bXlxcXFxbXSpcXFxcXSkpKlwiO1xudmFyIExJTktfSFJFRl9BTkRfVElUTEUgPVxuICAgICAgICBcIlxcXFxzKjw/KCg/OlxcXFwoW14pXSpcXFxcKXxbXlxcXFxzXFxcXFxcXFxdfFxcXFxcXFxcLikqPyk+Pyg/OlxcXFxzK1snXFxcIl0oW1xcXFxzXFxcXFNdKj8pWydcXFwiXSk/XFxcXHMqXCI7XG52YXIgQVVUT0xJTktfTUFJTFRPX0NIRUNLX1IgPSAvbWFpbHRvOi9pO1xuXG4vKipcbiAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uQ2FwdHVyZX0gY2FwdHVyZVxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5TdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uUmVmTm9kZX0gcmVmTm9kZVxuICogQHJldHVybnMge1NpbXBsZU1hcmtkb3duLlJlZk5vZGV9XG4gKi9cbnZhciBwYXJzZVJlZiA9IGZ1bmN0aW9uKGNhcHR1cmUsIHN0YXRlLCByZWZOb2RlIC8qIDogUmVmTm9kZSAqLykge1xuICAgIHZhciByZWYgPSAoY2FwdHVyZVsyXSB8fCBjYXB0dXJlWzFdKVxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gV2Ugc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgcHJldmlvdXNseSBzZWVuIGRlZnMgb25cbiAgICAvLyBzdGF0ZS5fZGVmcyAoXyB0byBkZWNvbmZsaWN0IHdpdGggY2xpZW50LWRlZmluZWRcbiAgICAvLyBzdGF0ZSkuIElmIHRoZSBkZWYgZm9yIHRoaXMgcmVmbGluay9yZWZpbWFnZSBoYXNcbiAgICAvLyBhbHJlYWR5IGJlZW4gc2Vlbiwgd2UgY2FuIHVzZSBpdHMgdGFyZ2V0L3NvdXJjZVxuICAgIC8vIGFuZCB0aXRsZSBoZXJlOlxuICAgIGlmIChzdGF0ZS5fZGVmcyAmJiBzdGF0ZS5fZGVmc1tyZWZdKSB7XG4gICAgICAgIHZhciBkZWYgPSBzdGF0ZS5fZGVmc1tyZWZdO1xuICAgICAgICAvLyBgcmVmTm9kZWAgY2FuIGJlIGEgbGluayBvciBhbiBpbWFnZS4gQm90aCB1c2VcbiAgICAgICAgLy8gdGFyZ2V0IGFuZCB0aXRsZSBwcm9wZXJ0aWVzLlxuICAgICAgICByZWZOb2RlLnRhcmdldCA9IGRlZi50YXJnZXQ7XG4gICAgICAgIHJlZk5vZGUudGl0bGUgPSBkZWYudGl0bGU7XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSB3ZSBoYXZlbid0IHNlZW4gb3VyIGRlZiB5ZXQgKG9yIGlmIHNvbWVvbmVcbiAgICAvLyBvdmVyd3JpdGVzIHRoYXQgZGVmIGxhdGVyIG9uKSwgd2UgYWRkIHRoaXMgbm9kZVxuICAgIC8vIHRvIHRoZSBsaXN0IG9mIHJlZiBub2RlcyBmb3IgdGhhdCBkZWYuIFRoZW4sIHdoZW5cbiAgICAvLyB3ZSBmaW5kIHRoZSBkZWYsIHdlIGNhbiBtb2RpZnkgdGhpcyBsaW5rL2ltYWdlIEFTVFxuICAgIC8vIG5vZGUgOikuXG4gICAgLy8gSSdtIHNvcnJ5LlxuICAgIHN0YXRlLl9yZWZzID0gc3RhdGUuX3JlZnMgfHwge307XG4gICAgc3RhdGUuX3JlZnNbcmVmXSA9IHN0YXRlLl9yZWZzW3JlZl0gfHwgW107XG4gICAgc3RhdGUuX3JlZnNbcmVmXS5wdXNoKHJlZk5vZGUpO1xuXG4gICAgcmV0dXJuIHJlZk5vZGU7XG59O1xuXG52YXIgY3Vyck9yZGVyID0gMDtcbi8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uRGVmYXVsdFJ1bGVzfSAqL1xudmFyIGRlZmF1bHRSdWxlcyAvKiA6IERlZmF1bHRSdWxlcyAqLyA9IHtcbiAgICBBcnJheToge1xuICAgICAgICByZWFjdDogZnVuY3Rpb24oYXJyLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgb2xkS2V5ID0gc3RhdGUua2V5O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCAvKiA6IEFycmF5PFJlYWN0RWxlbWVudHM+ICovID0gW107XG5cbiAgICAgICAgICAgIC8vIG1hcCBvdXRwdXQgb3ZlciB0aGUgYXN0LCBleGNlcHQgZ3JvdXAgYW55IHRleHRcbiAgICAgICAgICAgIC8vIG5vZGVzIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgc3RyaW5nIG91dHB1dC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrLCBrZXkrKykge1xuICAgICAgICAgICAgICAgIC8vIGBrZXlgIGlzIG91ciBudW1lcmljYWwgYHN0YXRlLmtleWAsIHdoaWNoIHdlIGluY3JlbWVudCBmb3JcbiAgICAgICAgICAgICAgICAvLyBldmVyeSBvdXRwdXQgbm9kZSwgYnV0IGRvbid0IGNoYW5nZSBmb3Igam9pbmVkIHRleHQgbm9kZXMuXG4gICAgICAgICAgICAgICAgLy8gKGksIGhvd2V2ZXIsIG11c3QgY2hhbmdlIGZvciBqb2luZWQgdGV4dCBub2RlcylcbiAgICAgICAgICAgICAgICBzdGF0ZS5rZXkgPSAnJyArIGk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmNvbnRlbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgKyAxIDwgYXJyLmxlbmd0aCAmJiBhcnJbaSArIDFdLnR5cGUgPT09ICd0ZXh0JzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgKz0gYXJyW2kgKyAxXS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob3V0cHV0KG5vZGUsIHN0YXRlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmtleSA9IG9sZEtleTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKGFyciwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIG1hcCBvdXRwdXQgb3ZlciB0aGUgYXN0LCBleGNlcHQgZ3JvdXAgYW55IHRleHRcbiAgICAgICAgICAgIC8vIG5vZGVzIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgc3RyaW5nIG91dHB1dC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmNvbnRlbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgKyAxIDwgYXJyLmxlbmd0aCAmJiBhcnJbaSArIDFdLnR5cGUgPT09ICd0ZXh0JzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgKz0gYXJyW2kgKyAxXS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG91dHB1dChub2RlLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoZWFkaW5nOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGJsb2NrUmVnZXgoL14gKigjezEsNn0pKFteXFxuXSs/KSMqICooPzpcXG4gKikrXFxuLyksXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihjYXB0dXJlLCBwYXJzZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGNhcHR1cmVbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnNlSW5saW5lKHBhcnNlLCBjYXB0dXJlWzJdLnRyaW0oKSwgc3RhdGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZWFjdDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAnaCcgKyBub2RlLmxldmVsLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbFRhZyhcImhcIiArIG5vZGUubGV2ZWwsIG91dHB1dChub2RlLmNvbnRlbnQsIHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG5wdGFibGU6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrLFxuICAgICAgICBtYXRjaDogYmxvY2tSZWdleChUQUJMRVMuTlBUQUJMRV9SRUdFWCksXG4gICAgICAgIHBhcnNlOiBUQUJMRVMucGFyc2VOcFRhYmxlLFxuICAgICAgICByZWFjdDogbnVsbCxcbiAgICAgICAgaHRtbDogbnVsbFxuICAgIH0sXG4gICAgbGhlYWRpbmc6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrLFxuICAgICAgICBtYXRjaDogYmxvY2tSZWdleCgvXihbXlxcbl0rKVxcbiAqKD18LSl7Myx9ICooPzpcXG4gKikrXFxuLyksXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihjYXB0dXJlLCBwYXJzZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGNhcHR1cmVbMl0gPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnNlSW5saW5lKHBhcnNlLCBjYXB0dXJlWzFdLCBzdGF0ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBudWxsLFxuICAgICAgICBodG1sOiBudWxsXG4gICAgfSxcbiAgICBocjoge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBibG9ja1JlZ2V4KC9eKCAqWy0qX10pezMsfSAqKD86XFxuICopK1xcbi8pLFxuICAgICAgICBwYXJzZTogaWdub3JlQ2FwdHVyZSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2hyJyxcbiAgICAgICAgICAgICAgICBzdGF0ZS5rZXksXG4gICAgICAgICAgICAgICAgRU1QVFlfUFJPUFNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxocj5cIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZUJsb2NrOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGJsb2NrUmVnZXgoL14oPzogICAgW15cXG5dK1xcbiopKyg/OlxcbiAqKStcXG4vKSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjYXB0dXJlWzBdXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL14gICAgL2dtLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuKyQvLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZWFjdDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUubGFuZyA/XG4gICAgICAgICAgICAgICAgXCJtYXJrZG93bi1jb2RlLVwiICsgbm9kZS5sYW5nIDpcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3ByZScsXG4gICAgICAgICAgICAgICAgc3RhdGUua2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaHRtbDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUubGFuZyA/XG4gICAgICAgICAgICAgICAgXCJtYXJrZG93bi1jb2RlLVwiICsgbm9kZS5sYW5nIDpcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHZhciBjb2RlQmxvY2sgPSBodG1sVGFnKFwiY29kZVwiLCBzYW5pdGl6ZVRleHQobm9kZS5jb250ZW50KSwge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJwcmVcIiwgY29kZUJsb2NrKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZmVuY2U6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrLFxuICAgICAgICBtYXRjaDogYmxvY2tSZWdleCgvXiAqKGB7Myx9fH57Myx9KSAqKD86KFxcUyspICopP1xcbihbXFxzXFxTXSs/KVxcbj9cXDEgKig/OlxcbiAqKStcXG4vKSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvZGVCbG9ja1wiLFxuICAgICAgICAgICAgICAgIGxhbmc6IGNhcHR1cmVbMl0gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcHR1cmVbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBudWxsLFxuICAgICAgICBodG1sOiBudWxsXG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGJsb2NrUmVnZXgoL14oICo+W15cXG5dKyhcXG5bXlxcbl0rKSpcXG4qKStcXG57Mix9LyksXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihjYXB0dXJlLCBwYXJzZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gY2FwdHVyZVswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogcGFyc2UoY29udGVudCwgc3RhdGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZWFjdDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICAgICAgc3RhdGUua2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IG91dHB1dChub2RlLmNvbnRlbnQsIHN0YXRlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sVGFnKFwiYmxvY2txdW90ZVwiLCBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsaXN0OiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKHNvdXJjZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBicmVhayBpbnRvIGEgbGlzdCBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGFcbiAgICAgICAgICAgIC8vIGxpbmUuIFRoaXMgaXMgdG8gYXZvaWQgcGFyc2luZyBcImhpICogdGhlcmVcIiB3aXRoIFwiKiB0aGVyZVwiXG4gICAgICAgICAgICAvLyBiZWNvbWluZyBhIHBhcnQgb2YgYSBsaXN0LlxuICAgICAgICAgICAgLy8gWW91IG1pZ2h0IHdvbmRlciwgXCJidXQgdGhhdCdzIGlubGluZSwgc28gb2YgY291cnNlIGl0IHdvdWxkbid0XG4gICAgICAgICAgICAvLyBzdGFydCBhIGxpc3Q/XCIuIFlvdSB3b3VsZCBiZSBjb3JyZWN0ISBFeGNlcHQgdGhhdCBzb21lIG9mIG91clxuICAgICAgICAgICAgLy8gbGlzdHMgY2FuIGJlIGlubGluZSwgYmVjYXVzZSB0aGV5IG1pZ2h0IGJlIGluc2lkZSBhbm90aGVyIGxpc3QsXG4gICAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGNhbiBwYXJzZSB3aXRoIGlubGluZSBzY29wZSwgYnV0IG5lZWQgdG8gYWxsb3dcbiAgICAgICAgICAgIC8vIG5lc3RlZCBsaXN0cyBpbnNpZGUgdGhpcyBpbmxpbmUgc2NvcGUuXG4gICAgICAgICAgICB2YXIgcHJldkNhcHR1cmVTdHIgPSBzdGF0ZS5wcmV2Q2FwdHVyZSA9PSBudWxsID8gXCJcIiA6IHN0YXRlLnByZXZDYXB0dXJlWzBdO1xuICAgICAgICAgICAgdmFyIGlzU3RhcnRPZkxpbmVDYXB0dXJlID0gTElTVF9MT09LQkVISU5EX1IuZXhlYyhwcmV2Q2FwdHVyZVN0cik7XG4gICAgICAgICAgICB2YXIgaXNMaXN0QmxvY2sgPSBzdGF0ZS5fbGlzdCB8fCAhc3RhdGUuaW5saW5lO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGFydE9mTGluZUNhcHR1cmUgJiYgaXNMaXN0QmxvY2spIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBpc1N0YXJ0T2ZMaW5lQ2FwdHVyZVsxXSArIHNvdXJjZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTElTVF9SLmV4ZWMoc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihjYXB0dXJlLCBwYXJzZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBidWxsZXQgPSBjYXB0dXJlWzJdO1xuICAgICAgICAgICAgdmFyIG9yZGVyZWQgPSBidWxsZXQubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG9yZGVyZWQgPyArYnVsbGV0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi8gKFxuICAgICAgICAgICAgICAgIGNhcHR1cmVbMF1cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoTElTVF9CTE9DS19FTkRfUiwgXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgLm1hdGNoKExJU1RfSVRFTV9SKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGlzIHdpbGwgbWF0Y2ggaGVyZSwgYmVjYXVzZSBvZiBob3cgdGhlIHJlZ2V4ZXMgYXJlXG4gICAgICAgICAgICAvLyBkZWZpbmVkXG4gICAgICAgICAgICAvKjo6IGl0ZW1zID0gKChpdGVtcyA6IGFueSkgOiBBcnJheTxzdHJpbmc+KSAqL1xuXG4gICAgICAgICAgICB2YXIgbGFzdEl0ZW1XYXNBUGFyYWdyYXBoID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXRlbUNvbnRlbnQgPSBpdGVtcy5tYXAoZnVuY3Rpb24oLyoqIEB0eXBlIHtzdHJpbmd9ICovIGl0ZW0sIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzZWUgaG93IGZhciBpbmRlbnRlZCB0aGlzIGl0ZW0gaXM6XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeENhcHR1cmUgPSBMSVNUX0lURU1fUFJFRklYX1IuZXhlYyhpdGVtKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBwcmVmaXhDYXB0dXJlID8gcHJlZml4Q2FwdHVyZVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIC8vIEFuZCB0aGVuIHdlIGNvbnN0cnVjdCBhIHJlZ2V4IHRvIFwidW5pbmRlbnRcIiB0aGUgc3Vic2VxdWVudFxuICAgICAgICAgICAgICAgIC8vIGxpbmVzIG9mIHRoZSBpdGVtcyBieSB0aGF0IGFtb3VudDpcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VSZWdleCA9IG5ldyBSZWdFeHAoXCJeIHsxLFwiICsgc3BhY2UgKyBcIn1cIiwgXCJnbVwiKTtcblxuICAgICAgICAgICAgICAgIC8vIEJlZm9yZSBwcm9jZXNzaW5nIHRoZSBpdGVtLCB3ZSBuZWVkIGEgY291cGxlIHRoaW5nc1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRlbnRzIG9uIHRyYWlsaW5nIGxpbmVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uoc3BhY2VSZWdleCwgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBidWxsZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShMSVNUX0lURU1fUFJFRklYX1IsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIEknbSBub3Qgc3VyNCB3aHkgdGhpcyBpcyBuZWNlc3NhcnkgYWdhaW4/XG4gICAgICAgICAgICAgICAgLyo6OiBpdGVtcyA9ICgoaXRlbXMgOiBhbnkpIDogQXJyYXk8c3RyaW5nPikgKi9cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsaW5nIFwibG9vc2VcIiBsaXN0cywgbGlrZTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAqIHRoaXMgaXMgd3JhcHBlZCBpbiBhIHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICogYXMgaXMgdGhpc1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICogYXMgaXMgdGhpc1xuICAgICAgICAgICAgICAgIHZhciBpc0xhc3RJdGVtID0gKGkgPT09IGl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluc0Jsb2NrcyA9IGNvbnRlbnQuaW5kZXhPZihcIlxcblxcblwiKSAhPT0gLTE7XG5cbiAgICAgICAgICAgICAgICAvLyBBbnkgZWxlbWVudCBpbiBhIGxpc3QgaXMgYSBibG9jayBpZiBpdCBjb250YWlucyBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIC8vIG5ld2xpbmVzLiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBsaXN0IGNhbiBhbHNvIGJlIGEgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgbGlzdCB3YXMgYSBibG9jayAodGhpcyBpc1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugbm9uLWxhc3QgaXRlbXMgaW4gdGhlIGxpc3QgY2FuIGVuZCB3aXRoIFxcblxcbiwgYnV0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlbSBjYW4ndCwgc28gd2UganVzdCBcImluaGVyaXRcIiB0aGlzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBvdXIgcHJldmlvdXMgZWxlbWVudCkuXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNJdGVtSXNBUGFyYWdyYXBoID0gY29udGFpbnNCbG9ja3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0xhc3RJdGVtICYmIGxhc3RJdGVtV2FzQVBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgbGFzdEl0ZW1XYXNBUGFyYWdyYXBoID0gdGhpc0l0ZW1Jc0FQYXJhZ3JhcGg7XG5cbiAgICAgICAgICAgICAgICAvLyBiYWNrdXAgb3VyIHN0YXRlIGZvciByZXN0b3JhdGlvbiBhZnRlcndhcmRzLiBXZSdyZSBnb2luZyB0b1xuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gc2V0IHN0YXRlLl9saXN0IHRvIHRydWUsIGFuZCBzdGF0ZS5pbmxpbmUgZGVwZW5kaW5nXG4gICAgICAgICAgICAgICAgLy8gb24gb3VyIGxpc3QncyBsb29zZW5lc3MuXG4gICAgICAgICAgICAgICAgdmFyIG9sZFN0YXRlSW5saW5lID0gc3RhdGUuaW5saW5lO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZUxpc3QgPSBzdGF0ZS5fbGlzdDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5fbGlzdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBpbmxpbmUgaWYgd2UncmUgaW4gYSB0aWdodCBsaXN0LCBvciBibG9jayBpZiB3ZSdyZSBpblxuICAgICAgICAgICAgICAgIC8vIGEgbG9vc2UgbGlzdC5cbiAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRDb250ZW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzSXRlbUlzQVBhcmFncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRDb250ZW50ID0gY29udGVudC5yZXBsYWNlKExJU1RfSVRFTV9FTkRfUiwgXCJcXG5cXG5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRDb250ZW50ID0gY29udGVudC5yZXBsYWNlKExJU1RfSVRFTV9FTkRfUiwgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlKGFkanVzdGVkQ29udGVudCwgc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvdXIgc3RhdGUgYmVmb3JlIHJldHVybmluZ1xuICAgICAgICAgICAgICAgIHN0YXRlLmlubGluZSA9IG9sZFN0YXRlSW5saW5lO1xuICAgICAgICAgICAgICAgIHN0YXRlLl9saXN0ID0gb2xkU3RhdGVMaXN0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBvcmRlcmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbUNvbnRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgTGlzdFdyYXBwZXIgPSBub2RlLm9yZGVyZWQgPyBcIm9sXCIgOiBcInVsXCI7XG5cbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgc3RhdGUua2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBub2RlLml0ZW1zLm1hcChmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQVNUTm9kZX0gKi8gaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQoaXRlbSwgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW1zID0gbm9kZS5pdGVtcy5tYXAoZnVuY3Rpb24oLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5BU1ROb2RlfSAqLyBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJsaVwiLCBvdXRwdXQoaXRlbSwgc3RhdGUpKTtcbiAgICAgICAgICAgIH0pLmpvaW4oXCJcIik7XG5cbiAgICAgICAgICAgIHZhciBsaXN0VGFnID0gbm9kZS5vcmRlcmVkID8gXCJvbFwiIDogXCJ1bFwiO1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuc3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaHRtbFRhZyhsaXN0VGFnLCBsaXN0SXRlbXMsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWY6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrLFxuICAgICAgICAvLyBUT0RPKGFyaWEpOiBUaGlzIHdpbGwgbWF0Y2ggd2l0aG91dCBhIGJsYW5rIGxpbmUgYmVmb3JlIHRoZSBuZXh0XG4gICAgICAgIC8vIGJsb2NrIGVsZW1lbnQsIHdoaWNoIGlzIGluY29uc2lzdGVudCB3aXRoIG1vc3Qgb2YgdGhlIHJlc3Qgb2ZcbiAgICAgICAgLy8gc2ltcGxlLW1hcmtkb3duLlxuICAgICAgICBtYXRjaDogYmxvY2tSZWdleChcbiAgICAgICAgICAgIC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKik+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICpcXG4oPzogKlxcbikqL1xuICAgICAgICApLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gY2FwdHVyZVsxXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBjYXB0dXJlWzJdO1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gY2FwdHVyZVszXTtcblxuICAgICAgICAgICAgLy8gTG9vayBmb3IgcHJldmlvdXMgbGlua3MvaW1hZ2VzIHVzaW5nIHRoaXMgZGVmXG4gICAgICAgICAgICAvLyBJZiBhbnkgbGlua3MvaW1hZ2VzIHVzaW5nIHRoaXMgZGVmIGhhdmUgYWxyZWFkeSBiZWVuIGRlY2xhcmVkLFxuICAgICAgICAgICAgLy8gdGhleSB3aWxsIGhhdmUgYWRkZWQgdGhlbXNlbHZlcyB0byB0aGUgc3RhdGUuX3JlZnNbZGVmXSBsaXN0XG4gICAgICAgICAgICAvLyAoXyB0byBkZWNvbmZsaWN0IHdpdGggY2xpZW50LWRlZmluZWQgc3RhdGUpLiBXZSBsb29rIHRocm91Z2hcbiAgICAgICAgICAgIC8vIHRoYXQgbGlzdCBvZiByZWZsaW5rcyBmb3IgdGhpcyBkZWYsIGFuZCBtb2RpZnkgdGhvc2UgQVNUIG5vZGVzXG4gICAgICAgICAgICAvLyB3aXRoIG91ciBuZXdseSBmb3VuZCBpbmZvcm1hdGlvbiBub3cuXG4gICAgICAgICAgICAvLyBTb3JyeSA6KC5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fcmVmcyAmJiBzdGF0ZS5fcmVmc1tkZWZdKSB7XG4gICAgICAgICAgICAgICAgLy8gYHJlZk5vZGVgIGNhbiBiZSBhIGxpbmsgb3IgYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICBzdGF0ZS5fcmVmc1tkZWZdLmZvckVhY2goZnVuY3Rpb24oLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5SZWZOb2RlfSAqLyByZWZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZk5vZGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZWZOb2RlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGlzIGRlZiB0byBvdXIgbWFwIG9mIGRlZnMgZm9yIGFueSBmdXR1cmUgbGlua3MvaW1hZ2VzXG4gICAgICAgICAgICAvLyBJbiBjYXNlIHdlIGhhdmVuJ3QgZm91bmQgYW55IG9yIGFsbCBvZiB0aGUgcmVmcyByZWZlcnJpbmcgdG9cbiAgICAgICAgICAgIC8vIHRoaXMgZGVmIHlldCwgd2UgYWRkIG91ciBkZWYgdG8gdGhlIHRhYmxlIG9mIGtub3duIGRlZnMsIHNvXG4gICAgICAgICAgICAvLyB0aGF0IGZ1dHVyZSByZWZsaW5rcyBjYW4gbW9kaWZ5IHRoZW1zZWx2ZXMgYXBwcm9wcmlhdGVseSB3aXRoXG4gICAgICAgICAgICAvLyB0aGlzIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgc3RhdGUuX2RlZnMgPSBzdGF0ZS5fZGVmcyB8fCB7fTtcbiAgICAgICAgICAgIHN0YXRlLl9kZWZzW2RlZl0gPSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSByZWxldmFudCBwYXJzZWQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGZvciBkZWJ1Z2dpbmcgb25seS5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgaHRtbDogZnVuY3Rpb24oKSB7IHJldHVybiBcIlwiOyB9XG4gICAgfSxcbiAgICB0YWJsZToge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBibG9ja1JlZ2V4KFRBQkxFUy5UQUJMRV9SRUdFWCksXG4gICAgICAgIHBhcnNlOiBUQUJMRVMucGFyc2VUYWJsZSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7eyBbYXR0cjogc3RyaW5nXTogU2ltcGxlTWFya2Rvd24uQXR0ciB9fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZ2V0U3R5bGUgPSBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmFsaWduW2NvbEluZGV4XSA9PSBudWxsID8ge30gOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogbm9kZS5hbGlnbltjb2xJbmRleF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBub2RlLmhlYWRlci5tYXAoZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5BU1ROb2RlfSAqLyBjb250ZW50LFxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhY3RFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgICAgICAgICAnJyArIGksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBnZXRTdHlsZShpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQoY29udGVudCwgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciByb3dzID0gbm9kZS5jZWxscy5tYXAoZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQVNUTm9kZVtdfSAqLyByb3csXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyByXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhY3RFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAndHInLFxuICAgICAgICAgICAgICAgICAgICAnJyArIHIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiByb3cubWFwKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQVNUTm9kZX0gKi8gY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gY1xuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgKyBjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogZ2V0U3R5bGUoYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogb3V0cHV0KGNvbnRlbnQsIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICBzdGF0ZS5rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW3JlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aGVhZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGhlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0cicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICksIHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICd0Ym9keScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGJvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaHRtbDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBnZXRTdHlsZSA9IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuYWxpZ25bY29sSW5kZXhdID09IG51bGwgPyBcIlwiIDpcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduOlwiICsgbm9kZS5hbGlnbltjb2xJbmRleF0gKyBcIjtcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gbm9kZS5oZWFkZXIubWFwKGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQVNUTm9kZX0gKi8gY29udGVudCxcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gaVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJ0aFwiLCBvdXRwdXQoY29udGVudCwgc3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICB7IHN0eWxlOiBnZXRTdHlsZShpKSwgc2NvcGU6IFwiY29sXCIgfSk7XG4gICAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuXG4gICAgICAgICAgICB2YXIgcm93cyA9IG5vZGUuY2VsbHMubWFwKGZ1bmN0aW9uKC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQVNUTm9kZVtdfSAqLyByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29scyA9IHJvdy5tYXAoZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQVNUTm9kZX0gKi8gY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGNcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJ0ZFwiLCBvdXRwdXQoY29udGVudCwgc3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzdHlsZTogZ2V0U3R5bGUoYykgfSk7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sVGFnKFwidHJcIiwgY29scyk7XG4gICAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuXG4gICAgICAgICAgICB2YXIgdGhlYWQgPSBodG1sVGFnKFwidGhlYWRcIiwgaHRtbFRhZyhcInRyXCIsIGhlYWRlcnMpKTtcbiAgICAgICAgICAgIHZhciB0Ym9keSA9IGh0bWxUYWcoXCJ0Ym9keVwiLCByb3dzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJ0YWJsZVwiLCB0aGVhZCArIHRib2R5KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbmV3bGluZToge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBibG9ja1JlZ2V4KC9eKD86XFxuICopKlxcbi8pLFxuICAgICAgICBwYXJzZTogaWdub3JlQ2FwdHVyZSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHsgcmV0dXJuIFwiXFxuXCI7IH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHsgcmV0dXJuIFwiXFxuXCI7IH1cbiAgICB9LFxuICAgIHBhcmFncmFwaDoge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBibG9ja1JlZ2V4KC9eKCg/OlteXFxuXXxcXG4oPyEgKlxcbikpKykoPzpcXG4gKikrXFxuLyksXG4gICAgICAgIHBhcnNlOiBwYXJzZUNhcHR1cmVJbmxpbmUsXG4gICAgICAgIHJlYWN0OiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhY3RFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICBjbGFzczogJ3BhcmFncmFwaCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaHRtbFRhZyhcImRpdlwiLCBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSksIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlc2NhcGU6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrLFxuICAgICAgICAvLyBXZSBkb24ndCBhbGxvdyBlc2NhcGluZyBudW1iZXJzLCBsZXR0ZXJzLCBvciBzcGFjZXMgaGVyZSBzbyB0aGF0XG4gICAgICAgIC8vIGJhY2tzbGFzaGVzIHVzZWQgaW4gcGxhaW4gdGV4dCBzdGlsbCBnZXQgcmVuZGVyZWQuIEJ1dCBhbGxvd2luZ1xuICAgICAgICAvLyBlc2NhcGluZyBhbnl0aGluZyBlbHNlIHByb3ZpZGVzIGEgdmVyeSBmbGV4aWJsZSBlc2NhcGUgbWVjaGFuaXNtLFxuICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGhvdyB0aGlzIGdyYW1tYXIgaXMgZXh0ZW5kZWQuXG4gICAgICAgIG1hdGNoOiBpbmxpbmVSZWdleCgvXlxcXFwoW14wLTlBLVphLXpcXHNdKS8pLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcHR1cmVbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBudWxsLFxuICAgICAgICBodG1sOiBudWxsXG4gICAgfSxcbiAgICB0YWJsZVNlcGFyYXRvcjoge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbihzb3VyY2UsIHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluVGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAvXiAqXFx8ICovLmV4ZWMoc291cmNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3RhYmxlU2VwYXJhdG9yJyB9O1xuICAgICAgICB9LFxuICAgICAgICAvLyBUaGVzZSBzaG91bGRuJ3QgYmUgcmVhY2hlZCwgYnV0IGluIGNhc2UgdGhleSBhcmUsIGJlIHJlYXNvbmFibGU6XG4gICAgICAgIHJlYWN0OiBmdW5jdGlvbigpIHsgcmV0dXJuICcgfCAnOyB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbigpIHsgcmV0dXJuICcgJnZlcnQ7ICc7IH0sXG4gICAgfSxcbiAgICBhdXRvbGluazoge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBpbmxpbmVSZWdleCgvXjwoW146ID5dKzpcXC9bXiA+XSspPi8pLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjYXB0dXJlWzFdXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjYXB0dXJlWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZWFjdDogbnVsbCxcbiAgICAgICAgaHRtbDogbnVsbFxuICAgIH0sXG4gICAgbWFpbHRvOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGlubGluZVJlZ2V4KC9ePChbXiA+XStAW14gPl0rKT4vKSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3MgPSBjYXB0dXJlWzFdO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNhcHR1cmVbMV07XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIGBtYWlsdG86YCBhbHJlYWR5IGV4aXN0aW5nIGluIHRoZSBsaW5rOlxuICAgICAgICAgICAgaWYgKCFBVVRPTElOS19NQUlMVE9fQ0hFQ0tfUi50ZXN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBcIm1haWx0bzpcIiArIHRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWRkcmVzc1xuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZWFjdDogbnVsbCxcbiAgICAgICAgaHRtbDogbnVsbFxuICAgIH0sXG4gICAgdXJsOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGlubGluZVJlZ2V4KC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvKSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY2FwdHVyZVsxXVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHRhcmdldDogY2FwdHVyZVsxXSxcbiAgICAgICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByZWFjdDogbnVsbCxcbiAgICAgICAgaHRtbDogbnVsbFxuICAgIH0sXG4gICAgbGluazoge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBpbmxpbmVSZWdleChuZXcgUmVnRXhwKFxuICAgICAgICAgICAgXCJeXFxcXFsoXCIgKyBMSU5LX0lOU0lERSArIFwiKVxcXFxdXFxcXChcIiArIExJTktfSFJFRl9BTkRfVElUTEUgKyBcIlxcXFwpXCJcbiAgICAgICAgKSksXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihjYXB0dXJlLCBwYXJzZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5rID17XG4gICAgICAgICAgICAgICAgY29udGVudDogcGFyc2UoY2FwdHVyZVsxXSwgc3RhdGUpLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdW5lc2NhcGVVcmwoY2FwdHVyZVsyXSksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNhcHR1cmVbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbGluaztcbiAgICAgICAgfSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHNhbml0aXplVXJsKG5vZGUudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5vZGUudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICBocmVmOiBzYW5pdGl6ZVVybChub2RlLnRhcmdldCksXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5vZGUudGl0bGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sVGFnKFwiYVwiLCBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSksIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbWFnZToge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBpbmxpbmVSZWdleChuZXcgUmVnRXhwKFxuICAgICAgICAgICAgXCJeIVxcXFxbKFwiICsgTElOS19JTlNJREUgKyBcIilcXFxcXVxcXFwoXCIgKyBMSU5LX0hSRUZfQU5EX1RJVExFICsgXCJcXFxcKVwiXG4gICAgICAgICkpLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgYWx0OiBjYXB0dXJlWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdW5lc2NhcGVVcmwoY2FwdHVyZVsyXSksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNhcHR1cmVbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhY3RFbGVtZW50KFxuICAgICAgICAgICAgICAgICdpbWcnLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNyYzogc2FuaXRpemVVcmwobm9kZS50YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICBhbHQ6IG5vZGUuYWx0LFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogbm9kZS50aXRsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgIHNyYzogc2FuaXRpemVVcmwobm9kZS50YXJnZXQpLFxuICAgICAgICAgICAgICAgIGFsdDogbm9kZS5hbHQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5vZGUudGl0bGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sVGFnKFwiaW1nXCIsIFwiXCIsIGF0dHJpYnV0ZXMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVmbGluazoge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyKyssXG4gICAgICAgIG1hdGNoOiBpbmxpbmVSZWdleChuZXcgUmVnRXhwKFxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IFtwYXJ0XSBvZiB0aGUgbGlua1xuICAgICAgICAgICAgXCJeXFxcXFsoXCIgKyBMSU5LX0lOU0lERSArIFwiKVxcXFxdXCIgK1xuICAgICAgICAgICAgLy8gVGhlIFtyZWZdIHRhcmdldCBvZiB0aGUgbGlua1xuICAgICAgICAgICAgXCJcXFxccypcXFxcWyhbXlxcXFxdXSopXFxcXF1cIlxuICAgICAgICApKSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVmKGNhcHR1cmUsIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogcGFyc2UoY2FwdHVyZVsxXSwgc3RhdGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhY3Q6IG51bGwsXG4gICAgICAgIGh0bWw6IG51bGxcbiAgICB9LFxuICAgIHJlZmltYWdlOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGlubGluZVJlZ2V4KG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgW3BhcnRdIG9mIHRoZSBsaW5rXG4gICAgICAgICAgICBcIl4hXFxcXFsoXCIgKyBMSU5LX0lOU0lERSArIFwiKVxcXFxdXCIgK1xuICAgICAgICAgICAgLy8gVGhlIFtyZWZdIHRhcmdldCBvZiB0aGUgbGlua1xuICAgICAgICAgICAgXCJcXFxccypcXFxcWyhbXlxcXFxdXSopXFxcXF1cIlxuICAgICAgICApKSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVmKGNhcHR1cmUsIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgIGFsdDogY2FwdHVyZVsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBudWxsLFxuICAgICAgICBodG1sOiBudWxsXG4gICAgfSxcbiAgICBlbToge1xuICAgICAgICBvcmRlcjogY3Vyck9yZGVyIC8qIHNhbWUgYXMgc3Ryb25nL3UgKi8sXG4gICAgICAgIG1hdGNoOiBpbmxpbmVSZWdleChcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgLy8gb25seSBtYXRjaCBfcyBzdXJyb3VuZGluZyB3b3Jkcy5cbiAgICAgICAgICAgICAgICBcIl5cXFxcYl9cIiArXG4gICAgICAgICAgICAgICAgXCIoKD86X198XFxcXFxcXFxbXFxcXHNcXFxcU118W15cXFxcXFxcXF9dKSs/KV9cIiArXG4gICAgICAgICAgICAgICAgXCJcXFxcYlwiICtcbiAgICAgICAgICAgICAgICAvLyBPciBtYXRjaCAqczpcbiAgICAgICAgICAgICAgICBcInxcIiArXG4gICAgICAgICAgICAgICAgLy8gT25seSBtYXRjaCAqcyB0aGF0IGFyZSBmb2xsb3dlZCBieSBhIG5vbi1zcGFjZTpcbiAgICAgICAgICAgICAgICBcIl5cXFxcKig/PVxcXFxTKShcIiArXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIG9mOlxuICAgICAgICAgICAgICAgIFwiKD86XCIgK1xuICAgICAgICAgICAgICAgICAgLy8gIC0gYCoqYDogc28gdGhhdCBib2xkcyBpbnNpZGUgaXRhbGljcyBkb24ndCBjbG9zZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIGl0YWxpY3NcbiAgICAgICAgICAgICAgICAgIFwiXFxcXCpcXFxcKnxcIiArXG4gICAgICAgICAgICAgICAgICAvLyAgLSBlc2NhcGUgc2VxdWVuY2U6IHNvIGVzY2FwZWQgKnMgZG9uJ3QgY2xvc2UgdXNcbiAgICAgICAgICAgICAgICAgIFwiXFxcXFxcXFxbXFxcXHNcXFxcU118XCIgK1xuICAgICAgICAgICAgICAgICAgLy8gIC0gd2hpdGVzcGFjZTogZm9sbG93ZWQgYnkgYSBub24tKiAod2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIHdhbnQgJyAqJyB0byBjbG9zZSBhbiBpdGFsaWNzLS1pdCBtaWdodFxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgc3RhcnQgYSBsaXN0KVxuICAgICAgICAgICAgICAgICAgXCJcXFxccysoPzpcXFxcXFxcXFtcXFxcc1xcXFxTXXxbXlxcXFxzXFxcXCpcXFxcXFxcXF18XFxcXCpcXFxcKil8XCIgK1xuICAgICAgICAgICAgICAgICAgLy8gIC0gbm9uLXdoaXRlc3BhY2UsIG5vbi0qLCBub24tYmFja3NsYXNoIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgIFwiW15cXFxcc1xcXFwqXFxcXFxcXFxdXCIgK1xuICAgICAgICAgICAgICAgIFwiKSs/XCIgK1xuICAgICAgICAgICAgICAgIC8vIGZvbGxvd2VkIGJ5IGEgbm9uLXNwYWNlLCBub24tKiB0aGVuICpcbiAgICAgICAgICAgICAgICBcIilcXFxcKig/IVxcXFwqKVwiXG4gICAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHF1YWxpdHk6IGZ1bmN0aW9uKGNhcHR1cmUpIHtcbiAgICAgICAgICAgIC8vIHByZWNlZGVuY2UgYnkgbGVuZ3RoLCBgZW1gIHdpbnMgdGllczpcbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlWzBdLmxlbmd0aCArIDAuMjtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNhcHR1cmUsIHBhcnNlLCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBwYXJzZShjYXB0dXJlWzJdIHx8IGNhcHR1cmVbMV0sIHN0YXRlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2VtJyxcbiAgICAgICAgICAgICAgICBzdGF0ZS5rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogb3V0cHV0KG5vZGUuY29udGVudCwgc3RhdGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaHRtbDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJlbVwiLCBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJvbmc6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlciAvKiBzYW1lIGFzIGVtICovLFxuICAgICAgICBtYXRjaDogaW5saW5lUmVnZXgoL15cXCpcXCooKD86XFxcXFtcXHNcXFNdfFteXFxcXF0pKz8pXFwqXFwqKD8hXFwqKS8pLFxuICAgICAgICBxdWFsaXR5OiBmdW5jdGlvbihjYXB0dXJlKSB7XG4gICAgICAgICAgICAvLyBwcmVjZWRlbmNlIGJ5IGxlbmd0aCwgd2lucyB0aWVzIHZzIGB1YDpcbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlWzBdLmxlbmd0aCArIDAuMTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IHBhcnNlQ2FwdHVyZUlubGluZSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgc3RhdGUua2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IG91dHB1dChub2RlLmNvbnRlbnQsIHN0YXRlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sVGFnKFwic3Ryb25nXCIsIG91dHB1dChub2RlLmNvbnRlbnQsIHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHU6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrIC8qIHNhbWUgYXMgZW0mc3Ryb25nOyBpbmNyZW1lbnQgZm9yIG5leHQgcnVsZSAqLyxcbiAgICAgICAgbWF0Y2g6IGlubGluZVJlZ2V4KC9eX18oKD86XFxcXFtcXHNcXFNdfFteXFxcXF0pKz8pX18oPyFfKS8pLFxuICAgICAgICBxdWFsaXR5OiBmdW5jdGlvbihjYXB0dXJlKSB7XG4gICAgICAgICAgICAvLyBwcmVjZWRlbmNlIGJ5IGxlbmd0aCwgbG9zZXMgYWxsIHRpZXNcbiAgICAgICAgICAgIHJldHVybiBjYXB0dXJlWzBdLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IHBhcnNlQ2FwdHVyZUlubGluZSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ3UnLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbFRhZyhcInVcIiwgb3V0cHV0KG5vZGUuY29udGVudCwgc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVsOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGlubGluZVJlZ2V4KC9efn4oPz1cXFMpKCg/OlxcXFxbXFxzXFxTXXx+KD8hfil8W15cXHN+XFxcXF18XFxzKD8hfn4pKSs/KX5+LyksXG4gICAgICAgIHBhcnNlOiBwYXJzZUNhcHR1cmVJbmxpbmUsXG4gICAgICAgIHJlYWN0OiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhY3RFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkZWwnLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBodG1sOiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbFRhZyhcImRlbFwiLCBvdXRwdXQobm9kZS5jb250ZW50LCBzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbmxpbmVDb2RlOiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgbWF0Y2g6IGlubGluZVJlZ2V4KC9eKGArKShbXFxzXFxTXSo/W15gXSlcXDEoPyFgKS8pLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oY2FwdHVyZSwgcGFyc2UsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcHR1cmVbMl0ucmVwbGFjZShJTkxJTkVfQ09ERV9FU0NBUEVfQkFDS1RJQ0tTX1IsIFwiJDFcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0OiBmdW5jdGlvbihub2RlLCBvdXRwdXQsIHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhY3RFbGVtZW50KFxuICAgICAgICAgICAgICAgICdjb2RlJyxcbiAgICAgICAgICAgICAgICBzdGF0ZS5rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogbm9kZS5jb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaHRtbDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxUYWcoXCJjb2RlXCIsIHNhbml0aXplVGV4dChub2RlLmNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYnI6IHtcbiAgICAgICAgb3JkZXI6IGN1cnJPcmRlcisrLFxuICAgICAgICBtYXRjaDogYW55U2NvcGVSZWdleCgvXiB7Mix9XFxuLyksXG4gICAgICAgIHBhcnNlOiBpZ25vcmVDYXB0dXJlLFxuICAgICAgICByZWFjdDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0RWxlbWVudChcbiAgICAgICAgICAgICAgICAnYnInLFxuICAgICAgICAgICAgICAgIHN0YXRlLmtleSxcbiAgICAgICAgICAgICAgICBFTVBUWV9QUk9QU1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaHRtbDogZnVuY3Rpb24obm9kZSwgb3V0cHV0LCBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPGJyPlwiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICAgIG9yZGVyOiBjdXJyT3JkZXIrKyxcbiAgICAgICAgLy8gSGVyZSB3ZSBsb29rIGZvciBhbnl0aGluZyBmb2xsb3dlZCBieSBub24tc3ltYm9scyxcbiAgICAgICAgLy8gZG91YmxlIG5ld2xpbmVzLCBvciBkb3VibGUtc3BhY2UtbmV3bGluZXNcbiAgICAgICAgLy8gV2UgYnJlYWsgb24gYW55IHN5bWJvbCBjaGFyYWN0ZXJzIHNvIHRoYXQgdGhpcyBncmFtbWFyXG4gICAgICAgIC8vIGlzIGVhc3kgdG8gZXh0ZW5kIHdpdGhvdXQgbmVlZGluZyB0byBtb2RpZnkgdGhpcyByZWdleFxuICAgICAgICBtYXRjaDogYW55U2NvcGVSZWdleChcbiAgICAgICAgICAgIC9eW1xcc1xcU10rPyg/PVteMC05QS1aYS16XFxzXFx1MDBjMC1cXHVmZmZmXXxcXG5cXG58IHsyLH1cXG58XFx3KzpcXFN8JCkvXG4gICAgICAgICksXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihjYXB0dXJlLCBwYXJzZSwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogY2FwdHVyZVswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhY3Q6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW5pdGl6ZVRleHQobm9kZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKiAoZGVwcmVjYXRlZClcbiAqIEBwYXJhbSB7YW55fSBydWxlc1xuICogQHBhcmFtIHthbnl9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG52YXIgcnVsZU91dHB1dCA9IGZ1bmN0aW9uLyogOjogPFJ1bGUgOiBPYmplY3Q+ICovKFxuICAgIHJ1bGVzIC8qIDogT3V0cHV0UnVsZXM8UnVsZT4gKi8sXG4gICAgcHJvcGVydHkgLyogOiAkS2V5czxSdWxlPiAqL1xuKSB7XG4gICAgaWYgKCFwcm9wZXJ0eSAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJzaW1wbGUtbWFya2Rvd24gcnVsZU91dHB1dCBzaG91bGQgdGFrZSAncmVhY3QnIG9yIFwiICtcbiAgICAgICAgICAgIFwiJ2h0bWwnIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1NpbXBsZU1hcmtkb3duLk5vZGVPdXRwdXQ8YW55Pn0gKi9cbiAgICB2YXIgbmVzdGVkUnVsZU91dHB1dCAvKiA6IE5vZGVPdXRwdXQ8YW55PiAqLyA9IGZ1bmN0aW9uKFxuICAgICAgICBhc3QgLyogOiBTaW5nbGVBU1ROb2RlICovLFxuICAgICAgICBvdXRwdXRGdW5jIC8qIDogT3V0cHV0PGFueT4gKi8sXG4gICAgICAgIHN0YXRlIC8qIDogU3RhdGUgKi9cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHJ1bGVzW2FzdC50eXBlXVtwcm9wZXJ0eV0oYXN0LCBvdXRwdXRGdW5jLCBzdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gbmVzdGVkUnVsZU91dHB1dDtcbn07XG5cbi8qKiAoZGVwcmVjYXRlZClcbiAqIEBwYXJhbSB7YW55fSBvdXRwdXRGdW5jXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG52YXIgcmVhY3RGb3IgPSBmdW5jdGlvbihvdXRwdXRGdW5jIC8qIDogUmVhY3ROb2RlT3V0cHV0ICovKSAvKiA6IFJlYWN0T3V0cHV0ICovIHtcbiAgICAvKiogQHR5cGUge1NpbXBsZU1hcmtkb3duLlJlYWN0T3V0cHV0fSAqL1xuICAgIHZhciBuZXN0ZWRPdXRwdXQgLyogOiBSZWFjdE91dHB1dCAqLyA9IGZ1bmN0aW9uKGFzdCwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgICAgICAgdmFyIG9sZEtleSA9IHN0YXRlLmtleTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgLyogOiBBcnJheTxSZWFjdEVsZW1lbnRzPiAqLyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBtYXAgbmVzdGVkT3V0cHV0IG92ZXIgdGhlIGFzdCwgZXhjZXB0IGdyb3VwIGFueSB0ZXh0XG4gICAgICAgICAgICAvLyBub2RlcyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHN0cmluZyBvdXRwdXQuXG4gICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN0YXRlLmtleSA9ICcnICsgaTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU91dCA9IG5lc3RlZE91dHB1dChhc3RbaV0sIHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGVPdXQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGxhc3RSZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3VsdCA9IGxhc3RSZXN1bHQgKyBub2RlT3V0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3VsdCA9IG5vZGVPdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5rZXkgPSBvbGRLZXk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEZ1bmMoYXN0LCBuZXN0ZWRPdXRwdXQsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5lc3RlZE91dHB1dDtcbn07XG5cbi8qKiAoZGVwcmVjYXRlZClcbiAqIEBwYXJhbSB7YW55fSBvdXRwdXRGdW5jXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG52YXIgaHRtbEZvciA9IGZ1bmN0aW9uKG91dHB1dEZ1bmMgLyogOiBIdG1sTm9kZU91dHB1dCAqLykgLyogOiBIdG1sT3V0cHV0ICovIHtcbiAgICAvKiogQHR5cGUge1NpbXBsZU1hcmtkb3duLkh0bWxPdXRwdXR9ICovXG4gICAgdmFyIG5lc3RlZE91dHB1dCAvKiA6IEh0bWxPdXRwdXQgKi8gPSBmdW5jdGlvbihhc3QsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwge307XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QubWFwKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVzdGVkT3V0cHV0KG5vZGUsIHN0YXRlKTtcbiAgICAgICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RnVuYyhhc3QsIG5lc3RlZE91dHB1dCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmVzdGVkT3V0cHV0O1xufTtcblxuLyoqXG4gKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uT3V0cHV0Rm9yfVxuICovXG52YXIgb3V0cHV0Rm9yID0gZnVuY3Rpb24vKiA6OiA8UnVsZSA6IE9iamVjdD4gKi8oXG4gICAgcnVsZXMgLyogOiBPdXRwdXRSdWxlczxSdWxlPiAqLyxcbiAgICBwcm9wZXJ0eSAvKiA6ICRLZXlzPFJ1bGU+ICovLFxuICAgIGRlZmF1bHRTdGF0ZSAvKiA6ID9TdGF0ZSAqL1xuKSB7XG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXBsZS1tYXJrZG93bjogb3V0cHV0Rm9yOiBgcHJvcGVydHlgIG11c3QgYmUgJyArXG4gICAgICAgICAgICAnZGVmaW5lZC4gJyArXG4gICAgICAgICAgICAnaWYgeW91IGp1c3QgdXBncmFkZWQsIHlvdSBwcm9iYWJseSBuZWVkIHRvIHJlcGxhY2UgYG91dHB1dEZvcmAgJyArXG4gICAgICAgICAgICAnd2l0aCBgcmVhY3RGb3JgJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uU3RhdGV9ICovXG4gICAgdmFyIGxhdGVzdFN0YXRlO1xuICAgIC8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uQXJyYXlSdWxlfSAqL1xuICAgIHZhciBhcnJheVJ1bGUgPSBydWxlcy5BcnJheSB8fCBkZWZhdWx0UnVsZXMuQXJyYXk7XG5cbiAgICAvLyBUcmlja3MgdG8gY29udmluY2UgdHNjIHRoYXQgdGhpcyB2YXIgaXMgbm90IG51bGw6XG4gICAgdmFyIGFycmF5UnVsZUNoZWNrID0gYXJyYXlSdWxlW3Byb3BlcnR5XTtcbiAgICBpZiAoIWFycmF5UnVsZUNoZWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2ltcGxlLW1hcmtkb3duOiBvdXRwdXRGb3I6IHRvIGpvaW4gbm9kZXMgb2YgdHlwZSBgJyArXG4gICAgICAgICAgICBwcm9wZXJ0eSArICdgIHlvdSBtdXN0IHByb3ZpZGUgYW4gYEFycmF5OmAgam9pbmVyIHJ1bGUgd2l0aCB0aGF0IHR5cGUsICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBzZWUgdGhlIGRvY3MgZm9yIGRldGFpbHMgb24gc3BlY2lmeWluZyBhbiBBcnJheSBydWxlLidcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdmFyIGFycmF5UnVsZU91dHB1dCA9IGFycmF5UnVsZUNoZWNrO1xuXG4gICAgLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5PdXRwdXQ8YW55Pn0gKi9cbiAgICB2YXIgbmVzdGVkT3V0cHV0IC8qIDogT3V0cHV0PGFueT4gKi8gPSBmdW5jdGlvbihhc3QsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwgbGF0ZXN0U3RhdGU7XG4gICAgICAgIGxhdGVzdFN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVJ1bGVPdXRwdXQoYXN0LCBuZXN0ZWRPdXRwdXQsIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlc1thc3QudHlwZV1bcHJvcGVydHldKGFzdCwgbmVzdGVkT3V0cHV0LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5PdXRwdXQ8YW55Pn0gKi9cbiAgICB2YXIgb3V0ZXJPdXRwdXQgPSBmdW5jdGlvbihhc3QsIHN0YXRlKSB7XG4gICAgICAgIGxhdGVzdFN0YXRlID0gcG9wdWxhdGVJbml0aWFsU3RhdGUoc3RhdGUsIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXN0ZWRPdXRwdXQoYXN0LCBsYXRlc3RTdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gb3V0ZXJPdXRwdXQ7XG59O1xuXG52YXIgZGVmYXVsdFJhd1BhcnNlID0gcGFyc2VyRm9yKGRlZmF1bHRSdWxlcyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAqIEBwYXJhbSB7U2ltcGxlTWFya2Rvd24uT3B0aW9uYWxTdGF0ZX0gW3N0YXRlXVxuICogQHJldHVybnMge0FycmF5PFNpbXBsZU1hcmtkb3duLlNpbmdsZUFTVE5vZGU+fVxuICovXG52YXIgZGVmYXVsdEJsb2NrUGFyc2UgPSBmdW5jdGlvbihzb3VyY2UsIHN0YXRlKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgICBzdGF0ZS5pbmxpbmUgPSBmYWxzZTtcbiAgICByZXR1cm4gZGVmYXVsdFJhd1BhcnNlKHNvdXJjZSwgc3RhdGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5PcHRpb25hbFN0YXRlfSBbc3RhdGVdXG4gKiBAcmV0dXJucyB7QXJyYXk8U2ltcGxlTWFya2Rvd24uU2luZ2xlQVNUTm9kZT59XG4gKi9cbnZhciBkZWZhdWx0SW5saW5lUGFyc2UgPSBmdW5jdGlvbihzb3VyY2UsIHN0YXRlKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgICBzdGF0ZS5pbmxpbmUgPSB0cnVlO1xuICAgIHJldHVybiBkZWZhdWx0UmF3UGFyc2Uoc291cmNlLCBzdGF0ZSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLk9wdGlvbmFsU3RhdGV9IFtzdGF0ZV1cbiAqIEByZXR1cm5zIHtBcnJheTxTaW1wbGVNYXJrZG93bi5TaW5nbGVBU1ROb2RlPn1cbiAqL1xudmFyIGRlZmF1bHRJbXBsaWNpdFBhcnNlID0gZnVuY3Rpb24oc291cmNlLCBzdGF0ZSkge1xuICAgIHZhciBpc0Jsb2NrID0gQkxPQ0tfRU5EX1IudGVzdChzb3VyY2UpO1xuICAgIHN0YXRlID0gc3RhdGUgfHwge307XG4gICAgc3RhdGUuaW5saW5lID0gIWlzQmxvY2s7XG4gICAgcmV0dXJuIGRlZmF1bHRSYXdQYXJzZShzb3VyY2UsIHN0YXRlKTtcbn07XG5cbi8qKiBAdHlwZSB7U2ltcGxlTWFya2Rvd24uUmVhY3RPdXRwdXR9ICovXG52YXIgZGVmYXVsdFJlYWN0T3V0cHV0IC8qIDogUmVhY3RPdXRwdXQgKi8gPSBvdXRwdXRGb3IoZGVmYXVsdFJ1bGVzLCBcInJlYWN0XCIpO1xuLyoqIEB0eXBlIHtTaW1wbGVNYXJrZG93bi5IdG1sT3V0cHV0fSAqL1xudmFyIGRlZmF1bHRIdG1sT3V0cHV0IC8qIDogSHRtbE91dHB1dCAqLyA9IG91dHB1dEZvcihkZWZhdWx0UnVsZXMsIFwiaHRtbFwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLk9wdGlvbmFsU3RhdGV9IFtzdGF0ZV1cbiAqIEByZXR1cm5zIHtTaW1wbGVNYXJrZG93bi5SZWFjdEVsZW1lbnRzfVxuICovXG52YXIgbWFya2Rvd25Ub1JlYWN0ID0gZnVuY3Rpb24oc291cmNlLCBzdGF0ZSkgLyogOiBSZWFjdEVsZW1lbnRzICovIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlYWN0T3V0cHV0KGRlZmF1bHRCbG9ja1BhcnNlKHNvdXJjZSwgc3RhdGUpLCBzdGF0ZSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gKiBAcGFyYW0ge1NpbXBsZU1hcmtkb3duLk9wdGlvbmFsU3RhdGV9IFtzdGF0ZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBtYXJrZG93blRvSHRtbCA9IGZ1bmN0aW9uKHNvdXJjZSwgc3RhdGUpIC8qIDogc3RyaW5nICovIHtcbiAgICByZXR1cm4gZGVmYXVsdEh0bWxPdXRwdXQoZGVmYXVsdEJsb2NrUGFyc2Uoc291cmNlLCBzdGF0ZSksIHN0YXRlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTaW1wbGVNYXJrZG93bi5SZWFjdE1hcmtkb3duUHJvcHN9IHByb3BzXG4gKiBAcmV0dXJucyB7U2ltcGxlTWFya2Rvd24uUmVhY3RFbGVtZW50fVxuICovXG52YXIgUmVhY3RNYXJrZG93biA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgdmFyIGRpdlByb3BzID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnc291cmNlJyAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpdlByb3BzW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2UHJvcHMuY2hpbGRyZW4gPSBtYXJrZG93blRvUmVhY3QocHJvcHMuc291cmNlKTtcblxuICAgIHJldHVybiByZWFjdEVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBudWxsLFxuICAgICAgICBkaXZQcm9wc1xuICAgICk7XG59O1xuXG5cbi8qOjogLy8gRmxvdyBleHBvcnRzOlxudHlwZSBFeHBvcnRzID0ge1xuICAgICtkZWZhdWx0UnVsZXM6IERlZmF1bHRSdWxlcyxcbiAgICArcGFyc2VyRm9yOiAocnVsZXM6IFBhcnNlclJ1bGVzLCBkZWZhdWx0U3RhdGU/OiA/U3RhdGUpID0+IFBhcnNlcixcbiAgICArb3V0cHV0Rm9yOiA8UnVsZSA6IE9iamVjdD4ocnVsZXM6IE91dHB1dFJ1bGVzPFJ1bGU+LCBwYXJhbTogJEtleXM8UnVsZT4sIGRlZmF1bHRTdGF0ZT86ID9TdGF0ZSkgPT4gT3V0cHV0PGFueT4sXG5cbiAgICArcnVsZU91dHB1dDogPFJ1bGUgOiBPYmplY3Q+KHJ1bGVzOiBPdXRwdXRSdWxlczxSdWxlPiwgcGFyYW06ICRLZXlzPFJ1bGU+KSA9PiBOb2RlT3V0cHV0PGFueT4sXG4gICAgK3JlYWN0Rm9yOiAoUmVhY3ROb2RlT3V0cHV0KSA9PiBSZWFjdE91dHB1dCxcbiAgICAraHRtbEZvcjogKEh0bWxOb2RlT3V0cHV0KSA9PiBIdG1sT3V0cHV0LFxuXG4gICAgK2lubGluZVJlZ2V4OiAocmVnZXg6IFJlZ0V4cCkgPT4gTWF0Y2hGdW5jdGlvbixcbiAgICArYmxvY2tSZWdleDogKHJlZ2V4OiBSZWdFeHApID0+IE1hdGNoRnVuY3Rpb24sXG4gICAgK2FueVNjb3BlUmVnZXg6IChyZWdleDogUmVnRXhwKSA9PiBNYXRjaEZ1bmN0aW9uLFxuICAgICtwYXJzZUlubGluZTogKHBhcnNlOiBQYXJzZXIsIGNvbnRlbnQ6IHN0cmluZywgc3RhdGU6IFN0YXRlKSA9PiBBU1ROb2RlLFxuICAgICtwYXJzZUJsb2NrOiAocGFyc2U6IFBhcnNlciwgY29udGVudDogc3RyaW5nLCBzdGF0ZTogU3RhdGUpID0+IEFTVE5vZGUsXG5cbiAgICArbWFya2Rvd25Ub1JlYWN0OiAoc291cmNlOiBzdHJpbmcsIHN0YXRlPzogP1N0YXRlKSA9PiBSZWFjdEVsZW1lbnRzLFxuICAgICttYXJrZG93blRvSHRtbDogKHNvdXJjZTogc3RyaW5nLCBzdGF0ZT86ID9TdGF0ZSkgPT4gc3RyaW5nLFxuICAgICtSZWFjdE1hcmtkb3duOiAocHJvcHM6IHsgc291cmNlOiBzdHJpbmcsIFtzdHJpbmddOiBhbnkgfSkgPT4gUmVhY3RFbGVtZW50LFxuXG4gICAgK2RlZmF1bHRSYXdQYXJzZTogKHNvdXJjZTogc3RyaW5nLCBzdGF0ZT86ID9TdGF0ZSkgPT4gQXJyYXk8U2luZ2xlQVNUTm9kZT4sXG4gICAgK2RlZmF1bHRCbG9ja1BhcnNlOiAoc291cmNlOiBzdHJpbmcsIHN0YXRlPzogP1N0YXRlKSA9PiBBcnJheTxTaW5nbGVBU1ROb2RlPixcbiAgICArZGVmYXVsdElubGluZVBhcnNlOiAoc291cmNlOiBzdHJpbmcsIHN0YXRlPzogP1N0YXRlKSA9PiBBcnJheTxTaW5nbGVBU1ROb2RlPixcbiAgICArZGVmYXVsdEltcGxpY2l0UGFyc2U6IChzb3VyY2U6IHN0cmluZywgc3RhdGU/OiA/U3RhdGUpID0+IEFycmF5PFNpbmdsZUFTVE5vZGU+LFxuXG4gICAgK2RlZmF1bHRSZWFjdE91dHB1dDogUmVhY3RPdXRwdXQsXG4gICAgK2RlZmF1bHRIdG1sT3V0cHV0OiBIdG1sT3V0cHV0LFxuXG4gICAgK3ByZXByb2Nlc3M6IChzb3VyY2U6IHN0cmluZykgPT4gc3RyaW5nLFxuICAgICtzYW5pdGl6ZVRleHQ6ICh0ZXh0OiBBdHRyKSA9PiBzdHJpbmcsXG4gICAgK3Nhbml0aXplVXJsOiAodXJsOiA/c3RyaW5nKSA9PiA/c3RyaW5nLFxuICAgICt1bmVzY2FwZVVybDogKHVybDogc3RyaW5nKSA9PiBzdHJpbmcsXG4gICAgK2h0bWxUYWc6ICh0YWdOYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgYXR0cmlidXRlczogP3sgW2FueV06ID9BdHRyIH0sIGlzQ2xvc2VkOiA/Ym9vbGVhbikgPT4gc3RyaW5nLFxuICAgICtyZWFjdEVsZW1lbnQ6ICh0eXBlOiBzdHJpbmcsIGtleTogc3RyaW5nIHwgbnVsbCwgcHJvcHM6IHsgW3N0cmluZ106IGFueSB9KSA9PiBSZWFjdEVsZW1lbnQsXG59O1xuXG5leHBvcnQgdHlwZSB7XG4gICAgLy8gSG9wZWZ1bGx5IHlvdSBzaG91bGRuJ3QgaGF2ZSB0byB1c2UgdGhlc2UsIGJ1dCB0aGV5J3JlIGhlcmUgaWYgeW91IG5lZWQhXG4gICAgLy8gVG9wLWxldmVsIEFQSTpcbiAgICBTdGF0ZSxcbiAgICBQYXJzZXIsXG4gICAgT3V0cHV0LFxuICAgIFJlYWN0T3V0cHV0LFxuICAgIEh0bWxPdXRwdXQsXG5cbiAgICAvLyBNb3N0IG9mIHRoZSBmb2xsb3dpbmcgdHlwZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZXhwZXJpbWVudGFsIGFuZFxuICAgIC8vIHN1YmplY3QgdG8gY2hhbmdlIG9yIGNoYW5nZSBuYW1lcy4gQWdhaW4sIHRoZXkgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSxcbiAgICAvLyBidXQgaWYgdGhleSBhcmUgSSdkIGxvdmUgdG8gaGVhciBob3cgc28gSSBjYW4gYmV0dGVyIHN1cHBvcnQgdGhlbSFcblxuICAgIC8vIEluZGl2aWR1YWwgUnVsZSBmaWVsZHM6XG4gICAgQ2FwdHVyZSxcbiAgICBNYXRjaEZ1bmN0aW9uLFxuICAgIFBhcnNlRnVuY3Rpb24sXG4gICAgTm9kZU91dHB1dCxcbiAgICBBcnJheU5vZGVPdXRwdXQsXG4gICAgUmVhY3ROb2RlT3V0cHV0LFxuXG4gICAgLy8gU2luZ2xlIHJ1bGVzOlxuICAgIFBhcnNlclJ1bGUsXG4gICAgUmVhY3RPdXRwdXRSdWxlLFxuICAgIEh0bWxPdXRwdXRSdWxlLFxuXG4gICAgLy8gU2V0cyBvZiBydWxlczpcbiAgICBQYXJzZXJSdWxlcyxcbiAgICBPdXRwdXRSdWxlcyxcbiAgICBSdWxlcyxcbiAgICBSZWFjdFJ1bGVzLFxuICAgIEh0bWxSdWxlcyxcbn07XG4qL1xuXG52YXIgU2ltcGxlTWFya2Rvd24gLyogOiBFeHBvcnRzICovID0ge1xuICAgIGRlZmF1bHRSdWxlczogZGVmYXVsdFJ1bGVzLFxuICAgIHBhcnNlckZvcjogcGFyc2VyRm9yLFxuICAgIG91dHB1dEZvcjogb3V0cHV0Rm9yLFxuXG4gICAgaW5saW5lUmVnZXg6IGlubGluZVJlZ2V4LFxuICAgIGJsb2NrUmVnZXg6IGJsb2NrUmVnZXgsXG4gICAgYW55U2NvcGVSZWdleDogYW55U2NvcGVSZWdleCxcbiAgICBwYXJzZUlubGluZTogcGFyc2VJbmxpbmUsXG4gICAgcGFyc2VCbG9jazogcGFyc2VCbG9jayxcblxuICAgIC8vIGRlZmF1bHQgd3JhcHBlcnM6XG4gICAgbWFya2Rvd25Ub1JlYWN0OiBtYXJrZG93blRvUmVhY3QsXG4gICAgbWFya2Rvd25Ub0h0bWw6IG1hcmtkb3duVG9IdG1sLFxuICAgIFJlYWN0TWFya2Rvd246IFJlYWN0TWFya2Rvd24sXG5cbiAgICBkZWZhdWx0QmxvY2tQYXJzZTogZGVmYXVsdEJsb2NrUGFyc2UsXG4gICAgZGVmYXVsdElubGluZVBhcnNlOiBkZWZhdWx0SW5saW5lUGFyc2UsXG4gICAgZGVmYXVsdEltcGxpY2l0UGFyc2U6IGRlZmF1bHRJbXBsaWNpdFBhcnNlLFxuXG4gICAgZGVmYXVsdFJlYWN0T3V0cHV0OiBkZWZhdWx0UmVhY3RPdXRwdXQsXG4gICAgZGVmYXVsdEh0bWxPdXRwdXQ6IGRlZmF1bHRIdG1sT3V0cHV0LFxuXG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2VzcyxcbiAgICBzYW5pdGl6ZVRleHQ6IHNhbml0aXplVGV4dCxcbiAgICBzYW5pdGl6ZVVybDogc2FuaXRpemVVcmwsXG4gICAgdW5lc2NhcGVVcmw6IHVuZXNjYXBlVXJsLFxuICAgIGh0bWxUYWc6IGh0bWxUYWcsXG4gICAgcmVhY3RFbGVtZW50OiByZWFjdEVsZW1lbnQsXG5cbiAgICAvLyBkZXByZWNhdGVkOlxuICAgIGRlZmF1bHRSYXdQYXJzZTogZGVmYXVsdFJhd1BhcnNlLFxuICAgIHJ1bGVPdXRwdXQ6IHJ1bGVPdXRwdXQsXG4gICAgcmVhY3RGb3I6IHJlYWN0Rm9yLFxuICAgIGh0bWxGb3I6IGh0bWxGb3IsXG5cbiAgICBkZWZhdWx0UGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2RlZmF1bHRQYXJzZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBkZWZhdWx0SW1wbGljaXRQYXJzZWAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdEltcGxpY2l0UGFyc2UuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGRlZmF1bHRPdXRwdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2RlZmF1bHRPdXRwdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgZGVmYXVsdFJlYWN0T3V0cHV0YCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0UmVhY3RPdXRwdXQuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChhcmd1bWVudHMpKTtcbiAgICB9XG59O1xuXG5yZXR1cm4gU2ltcGxlTWFya2Rvd247XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/simple-markdown/simple-markdown.js\n");

/***/ })

};
;